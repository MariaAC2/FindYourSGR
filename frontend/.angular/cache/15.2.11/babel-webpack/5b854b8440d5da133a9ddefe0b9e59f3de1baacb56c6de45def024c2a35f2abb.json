{"ast":null,"code":"import _asyncToGenerator from \"/home/alex/FindYourSGR/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.28/esri/copyright.txt for details.\n*/\nimport { _ as e } from \"../chunks/tslib.es6.js\";\nimport r from \"../PopupTemplate.js\";\nimport \"../renderers/ClassBreaksRenderer.js\";\nimport \"../renderers/DictionaryRenderer.js\";\nimport \"../renderers/DotDensityRenderer.js\";\nimport \"../renderers/HeatmapRenderer.js\";\nimport \"../renderers/PieChartRenderer.js\";\nimport \"../renderers/Renderer.js\";\nimport \"../renderers/SimpleRenderer.js\";\nimport \"../renderers/UniqueValueRenderer.js\";\nimport { read as t } from \"../renderers/support/jsonUtils.js\";\nimport { rendererTypes as i, webSceneRendererTypes as o } from \"../renderers/support/types.js\";\nimport s from \"../request.js\";\nimport { symbolTypes as a } from \"../symbols.js\";\nimport { ClonableMixin as n } from \"../core/Clonable.js\";\nimport l from \"../core/Collection.js\";\nimport p from \"../core/Error.js\";\nimport { clone as u } from \"../core/lang.js\";\nimport d from \"../core/Logger.js\";\nimport { MultiOriginJSONMixin as y } from \"../core/MultiOriginJSONSupport.js\";\nimport { setDeepValue as c } from \"../core/object.js\";\nimport { debounce as m, throwIfAbortError as f, whenOrAbort as h } from \"../core/promiseUtils.js\";\nimport { sqlAnd as b } from \"../core/sql.js\";\nimport { urlToObject as g, join as w } from \"../core/urlUtils.js\";\nimport { property as v } from \"../core/accessorSupport/decorators/property.js\";\nimport { cast as j } from \"../core/accessorSupport/decorators/cast.js\";\nimport { reader as S } from \"../core/accessorSupport/decorators/reader.js\";\nimport { subclass as F } from \"../core/accessorSupport/decorators/subclass.js\";\nimport { writer as I } from \"../core/accessorSupport/decorators/writer.js\";\nimport { excludeTables as T } from \"../core/accessorSupport/layerContainerType.js\";\nimport E from \"../form/FormTemplate.js\";\nimport D from \"../geometry/SpatialReference.js\";\nimport L from \"./Layer.js\";\nimport { MemorySource as _ } from \"./graphics/sources/MemorySource.js\";\nimport { APIKeyMixin as x } from \"./mixins/APIKeyMixin.js\";\nimport { ArcGISService as P } from \"./mixins/ArcGISService.js\";\nimport { BlendLayer as M } from \"./mixins/BlendLayer.js\";\nimport { CustomParametersMixin as q } from \"./mixins/CustomParametersMixin.js\";\nimport { EditBusLayer as C } from \"./mixins/EditBusLayer.js\";\nimport { FeatureEffectLayer as O } from \"./mixins/FeatureEffectLayer.js\";\nimport { FeatureLayerBase as R } from \"./mixins/FeatureLayerBase.js\";\nimport { FeatureReductionLayer as A } from \"./mixins/FeatureReductionLayer.js\";\nimport { OperationalLayer as V } from \"./mixins/OperationalLayer.js\";\nimport { OrderedLayer as U } from \"./mixins/OrderedLayer.js\";\nimport { PortalLayer as Q } from \"./mixins/PortalLayer.js\";\nimport { PublishableLayer as N } from \"./mixins/PublishableLayer.js\";\nimport { RefreshableLayer as $ } from \"./mixins/RefreshableLayer.js\";\nimport { ScaleRangeLayer as G } from \"./mixins/ScaleRangeLayer.js\";\nimport { TemporalLayer as J } from \"./mixins/TemporalLayer.js\";\nimport { titleFromUrlAndName as W, parse as B, cleanTitle as Z } from \"./support/arcgisLayerUrl.js\";\nimport { id as H, labelsVisible as k, opacityDrawingInfo as z, legendEnabled as K, listMode as X, popupEnabled as Y, screenSizePerspectiveEnabled as ee } from \"./support/commonProperties.js\";\nimport { ensureLayerCredential as re, computeEffectiveEditingEnabled as te, readGlobalIdField as ie, readObjectIdField as oe, createDefaultRenderer as se, addAttachment as ae, updateAttachment as ne, applyEdits as le, uploadAssets as pe, createQuery as ue, deleteAttachments as de, fetchRecomputedExtents as ye, queryAttachments as ce, queryObjectIds as me, queryFeatureCount as fe, queryExtent as he, queryRelatedFeatures as be, queryRelatedFeaturesCount as ge, hasDataChanged as we, geometryTypeKebabDict as ve } from \"./support/featureLayerUtils.js\";\nimport je from \"./support/FeatureTemplate.js\";\nimport Se from \"./support/FeatureType.js\";\nimport { defineFieldProperties as Fe } from \"./support/fieldProperties.js\";\nimport { fixRendererFields as Ie, fixTimeInfoFields as Te } from \"./support/fieldUtils.js\";\nimport Ee from \"./support/LabelClass.js\";\nimport { reader as De } from \"./support/labelingInfo.js\";\nimport { getFeatureLayerCapabilities as Le } from \"./support/serviceCapabilitiesUtils.js\";\nimport _e from \"./support/TimeInfo.js\";\nimport { serviceSupportsSpatialReference as xe } from \"./support/versionUtils.js\";\nimport { DataLayerSource as Pe } from \"./support/source/DataLayerSource.js\";\nimport { loadStyleRenderer as Me } from \"../renderers/support/styleUtils.js\";\nimport qe from \"../rest/support/FeatureSet.js\";\nimport Ce from \"../rest/support/Query.js\";\nimport Oe from \"../rest/support/TopFeaturesQuery.js\";\nimport { createPopupTemplate as Re } from \"../support/popupUtils.js\";\nimport { SaveOperationType as Ae } from \"../webdoc/interfaces.js\";\nimport { opacityToTransparency as Ve } from \"../webdoc/support/opacityUtils.js\";\nconst Ue = \"FeatureLayer\",\n  Qe = \"esri.layers.FeatureLayer\",\n  Ne = d.getLogger(Qe);\nfunction $e(e, r) {\n  return new p(\"layer:unsupported\", `Layer (${e.title}, ${e.id}) of type '${e.declaredClass}' ${r}`, {\n    layer: e\n  });\n}\nfunction Ge(e) {\n  return e && e instanceof l;\n}\nconst Je = Fe();\nfunction We(e, r, t) {\n  const i = !!t?.writeLayerSchema;\n  return {\n    enabled: i,\n    ignoreOrigin: i\n  };\n}\nlet Be = class extends R(A(O(N(C(M(U(J(G($(P(V(Q(y(q(x(n(L))))))))))))))))) {\n  constructor(...e) {\n    var _this;\n    (super(...e), _this = this), this.charts = null, this.copyright = null, this.displayField = null, this.dynamicDataSource = null, this.fields = null, this.fieldsIndex = null, this.formTemplate = null, this.fullExtent = null, this.geometryType = null, this.hasM = void 0, this.hasZ = void 0, this.infoFor3D = null, this.isTable = !1, this.labelsVisible = !0, this.labelingInfo = null, this.legendEnabled = !0, this.objectIdField = null, this.outFields = null, this.path = null, this.popupEnabled = !0, this.popupTemplate = null, this.resourceInfo = null, this.screenSizePerspectiveEnabled = !0, this.spatialReference = D.WGS84, this.subtypeCode = null, this.templates = null, this.timeInfo = null, this.title = null, this.sublayerTitleMode = \"item-title\", this.type = \"feature\", this.typeIdField = null, this.types = null, this.visible = !0, this._debouncedSaveOperations = m( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (e, r, t) {\n        const {\n          save: i,\n          saveAs: o\n        } = yield import(\"./save/featureLayerUtils.js\");\n        switch (e) {\n          case Ae.SAVE:\n            return i(_this, r);\n          case Ae.SAVE_AS:\n            return o(_this, t, r);\n        }\n      });\n      return function (_x, _x2, _x3) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  }\n  destroy() {\n    this.source?.destroy();\n  }\n  normalizeCtorArgs(e, r) {\n    return \"string\" == typeof e ? {\n      url: e,\n      ...r\n    } : e;\n  }\n  load(e) {\n    var _this2 = this;\n    const r = null != e ? e.signal : null;\n    if (this.portalItem?.loaded && this.source) return this.addResolvingPromise(this.createGraphicsSource(r).then(e => this.initLayerProperties(e))), Promise.resolve(this);\n    const t = this.loadFromPortal({\n      supportedTypes: [\"Feature Service\", \"Feature Collection\", \"Scene Service\"]\n    }, e).catch(f).then( /*#__PURE__*/_asyncToGenerator(function* () {\n      if (_this2.url && null == _this2.layerId && /FeatureServer|MapServer\\/*$/i.test(_this2.url)) {\n        const e = yield _this2._fetchFirstValidLayerId(r);\n        null != e && (_this2.layerId = e);\n      }\n      if (!_this2.url && !_this2._hasMemorySource()) throw new p(\"feature-layer:missing-url-or-source\", \"Feature layer must be created with either a url or a source\");\n      return _this2.initLayerProperties(yield _this2.createGraphicsSource(r));\n    })).then(() => re(this, \"load\", e));\n    return this.addResolvingPromise(t), Promise.resolve(this);\n  }\n  readCapabilities(e, r) {\n    return r = r.layerDefinition || r, Le(r, this.url);\n  }\n  get createQueryVersion() {\n    return this.commitProperty(\"definitionExpression\"), this.commitProperty(\"dynamicDataSource\"), this.commitProperty(\"timeExtent\"), this.commitProperty(\"timeOffset\"), this.commitProperty(\"geometryType\"), this.commitProperty(\"gdbVersion\"), this.commitProperty(\"historicMoment\"), this.commitProperty(\"returnZ\"), this.commitProperty(\"capabilities\"), this.commitProperty(\"returnM\"), (this._get(\"createQueryVersion\") ?? 0) + 1;\n  }\n  get editingEnabled() {\n    return !(this.loaded && !this.capabilities?.operations.supportsEditing) && (this._isOverridden(\"editingEnabled\") ? this._get(\"editingEnabled\") : this._hasMemorySource() || this.userHasEditingPrivileges);\n  }\n  set editingEnabled(e) {\n    this._overrideIfSome(\"editingEnabled\", e);\n  }\n  readEditingEnabled(e, r) {\n    return this._readEditingEnabled(r, !1);\n  }\n  readEditingEnabledFromWebMap(e, r, t) {\n    return this._readEditingEnabled(r, !0, t);\n  }\n  writeEditingEnabled(e, r) {\n    this._writeEditingEnabled(e, r, !1);\n  }\n  writeEditingEnabledToWebMap(e, r, t, i) {\n    this._writeEditingEnabled(e, r, !0, i);\n  }\n  get effectiveEditingEnabled() {\n    return te(this);\n  }\n  readIsTable(e, r) {\n    return \"Table\" === (r = r?.layerDefinition ?? r).type || !r.geometryType;\n  }\n  writeIsTable(e, r, t, i) {\n    i?.writeLayerSchema && c(t, e ? \"Table\" : \"Feature Layer\", r);\n  }\n  readGlobalIdField(e, r) {\n    return ie(r.layerDefinition || r);\n  }\n  readObjectIdField(e, r) {\n    return oe(r.layerDefinition || r);\n  }\n  get parsedUrl() {\n    const e = g(this.url);\n    return null != e && (null != this.dynamicDataSource ? e.path = w(e.path, \"dynamicLayer\") : null != this.layerId && (e.path = w(e.path, this.layerId.toString()))), e;\n  }\n  get defaultPopupTemplate() {\n    return this.createPopupTemplate();\n  }\n  set renderer(e) {\n    Ie(e, this.fieldsIndex), this._set(\"renderer\", e);\n  }\n  readRenderer(e, r, i) {\n    r = r.layerDefinition || r;\n    const o = r.drawingInfo?.renderer;\n    if (o) {\n      const e = t(o, r, i) ?? void 0;\n      return e || Ne.error(\"Failed to create renderer\", {\n        rendererDefinition: r.drawingInfo.renderer,\n        layer: this,\n        context: i\n      }), e;\n    }\n    return se(r, i);\n  }\n  set source(e) {\n    const r = this._get(\"source\");\n    r !== e && (Ge(r) && this._resetMemorySource(r), Ge(e) && this._initMemorySource(e), this._set(\"source\", e));\n  }\n  castSource(e) {\n    return e ? Array.isArray(e) || e instanceof l ? new _({\n      layer: this,\n      items: e\n    }) : e : null;\n  }\n  readSource(e, r) {\n    const t = qe.fromJSON(r.featureSet);\n    return new _({\n      layer: this,\n      items: t?.features ?? []\n    });\n  }\n  readTemplates(e, r) {\n    const t = r.editFieldsInfo,\n      i = t?.creatorField,\n      o = t?.editorField;\n    return e = e?.map(e => je.fromJSON(e)), this._fixTemplates(e, i), this._fixTemplates(e, o), e;\n  }\n  readTitle(e, r) {\n    const t = r.layerDefinition?.name ?? r.name,\n      i = r.title || r.layerDefinition?.title;\n    if (t) {\n      const e = this.portalItem?.title;\n      if (\"item-title\" === this.sublayerTitleMode) return this.url ? W(this.url, t) : t;\n      let r = t;\n      if (!r && this.url) {\n        const e = B(this.url);\n        null != e && (r = e.title);\n      }\n      if (!r) return;\n      return \"item-title-and-service-name\" === this.sublayerTitleMode && e && e !== r && (r = e + \" - \" + r), Z(r);\n    }\n    if (\"item-title\" === this.sublayerTitleMode && i) return i;\n  }\n  readTitleFromWebMap(e, r) {\n    return r.title || r.layerDefinition?.name;\n  }\n  readTypeIdField(e, r) {\n    let t = (r = r.layerDefinition || r).typeIdField;\n    if (t && r.fields) {\n      t = t.toLowerCase();\n      const e = r.fields.find(e => e.name.toLowerCase() === t);\n      e && (t = e.name);\n    }\n    return t;\n  }\n  readTypes(e, r) {\n    e = (r = r.layerDefinition || r).types;\n    const t = r.editFieldsInfo,\n      i = t?.creatorField,\n      o = t?.editorField;\n    return e?.map(e => (e = Se.fromJSON(e), this._fixTemplates(e.templates, i), this._fixTemplates(e.templates, o), e));\n  }\n  readVisible(e, r) {\n    return null != r.layerDefinition?.defaultVisibility ? !!r.layerDefinition.defaultVisibility : null != r.visibility ? !!r.visibility : void 0;\n  }\n  addAttachment(e, r) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return ae(_this3, e, r, Ue);\n    })();\n  }\n  updateAttachment(e, r, t) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return ne(_this4, e, r, t, Ue);\n    })();\n  }\n  applyEdits(e, r) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return le(_this5, e, r);\n    })();\n  }\n  uploadAssets(e, r) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return pe(_this6, e, r);\n    })();\n  }\n  on(e, r) {\n    return super.on(e, r);\n  }\n  createPopupTemplate(e) {\n    return Re(this, e);\n  }\n  createGraphicsSource(e) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (_this7._hasMemorySource() && _this7.source) return _this7.source.load({\n        signal: e\n      });\n      const {\n        default: r\n      } = yield h(import(\"./graphics/sources/FeatureLayerSource.js\"), e);\n      return new r({\n        layer: _this7\n      }).load({\n        signal: e\n      });\n    })();\n  }\n  createQuery() {\n    const e = ue(this);\n    e.dynamicDataSource = this.dynamicDataSource;\n    const r = null != this.subtypeCode ? `${this.subtypeField} = ${this.subtypeCode}` : null,\n      t = b(this.definitionExpression, r);\n    return e.where = t || \"1=1\", e;\n  }\n  deleteAttachments(e, r) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      return de(_this8, e, r, Ue);\n    })();\n  }\n  fetchRecomputedExtents(e) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      return ye(_this9, e, Ue);\n    })();\n  }\n  getFeatureType(e) {\n    const {\n      typeIdField: r,\n      types: t\n    } = this;\n    if (!r || !e) return null;\n    const i = e.attributes ? e.attributes[r] : void 0;\n    if (null == i) return null;\n    let o = null;\n    return t?.some(e => {\n      const {\n        id: r\n      } = e;\n      return null != r && (r.toString() === i.toString() && (o = e), !!o);\n    }), o;\n  }\n  getFieldDomain(e, r) {\n    const t = r?.feature,\n      i = this.getFeatureType(t);\n    if (i) {\n      const r = i.domains && i.domains[e];\n      if (r && \"inherited\" !== r.type) return r;\n    }\n    return this._getLayerDomain(e);\n  }\n  getField(e) {\n    return this.fieldsIndex.get(e);\n  }\n  queryAttachments(e, r) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      return ce(_this10, e, r, Ue);\n    })();\n  }\n  queryFeatures(e, r) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const t = yield _this11.load(),\n        i = yield t.source.queryFeatures(Ce.from(e) ?? t.createQuery(), r);\n      if (i?.features) for (const o of i.features) o.layer = o.sourceLayer = t;\n      return i;\n    })();\n  }\n  queryObjectIds(e, r) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      return me(_this12, e, r, Ue);\n    })();\n  }\n  queryFeatureCount(e, r) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      return fe(_this13, e, r, Ue);\n    })();\n  }\n  queryExtent(e, r) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      return he(_this14, e, r, Ue);\n    })();\n  }\n  queryRelatedFeatures(e, r) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      return be(_this15, e, r, Ue);\n    })();\n  }\n  queryRelatedFeaturesCount(e, r) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      return ge(_this16, e, r, Ue);\n    })();\n  }\n  queryTopFeatures(e, r) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        source: t,\n        capabilities: i\n      } = yield _this17.load();\n      if (!t.queryTopFeatures || !i?.query?.supportsTopFeaturesQuery) throw new p(Ue, \"Layer source does not support queryTopFeatures capability\");\n      const o = yield t.queryTopFeatures(Oe.from(e), r);\n      if (o?.features) for (const s of o.features) s.layer = s.sourceLayer = _this17;\n      return o;\n    })();\n  }\n  queryTopObjectIds(e, r) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        source: t,\n        capabilities: i\n      } = yield _this18.load();\n      if (!t.queryTopObjectIds || !i?.query.supportsTopFeaturesQuery) throw new p(Ue, \"Layer source does not support queryTopObjectIds capability\");\n      return t.queryTopObjectIds(Oe.from(e), r);\n    })();\n  }\n  queryTopFeaturesExtent(e, r) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        source: t,\n        capabilities: i\n      } = yield _this19.load();\n      if (!t.queryTopExtents || !i?.query?.supportsTopFeaturesQuery) throw new p(Ue, \"Layer source does not support queryTopExtents capability\");\n      return t.queryTopExtents(Oe.from(e), r);\n    })();\n  }\n  queryTopFeatureCount(e, r) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        source: t,\n        capabilities: i\n      } = yield _this20.load();\n      if (!t.queryTopCount || !i?.query?.supportsTopFeaturesQuery) throw new p(Ue, \"Layer source does not support queryFeatureCount capability\");\n      return t.queryTopCount(Oe.from(e), r);\n    })();\n  }\n  read(e, r) {\n    const t = e.featureCollection;\n    if (t) {\n      this.resourceInfo = e;\n      const i = t.layers;\n      i && 1 === i.length && (super.read(i[0], r), null != t.showLegend && super.read({\n        showLegend: t.showLegend\n      }, r));\n    }\n    super.read(e, r), r && \"service\" === r.origin && (this.revert([\"objectIdField\", \"fields\", \"timeInfo\", \"dateFieldsTimeZone\"], \"service\"), this.spatialReference || this.revert([\"spatialReference\"], \"service\"));\n  }\n  write(e, r) {\n    r = {\n      ...r,\n      origin: r?.origin ?? void 0,\n      writeLayerSchema: r?.writeLayerSchema ?? this._hasMemorySource()\n    };\n    const {\n      origin: t,\n      layerContainerType: i,\n      messages: o\n    } = r;\n    if (this.dynamicDataSource) return o?.push($e(this, \"using a dynamic data source cannot be written to web scenes, web maps and feature service items\")), null;\n    if (this.isTable) {\n      if ((\"web-map\" === t || \"web-scene\" === t) && \"tables\" !== i) return o?.push($e(this, `a table source can only be written to tables, not ${i}`)), null;\n      if (this._hasMemorySource()) return o?.push($e(this, \"using an in-memory table source cannot be written to web scenes and web maps\")), null;\n    } else if (this.loaded && (\"web-map\" === t || \"web-scene\" === t) && \"tables\" === i) return o?.push($e(this, \"using a non-table source cannot be written to tables in web maps or web scenes\")), null;\n    return super.write(e, r);\n  }\n  clone() {\n    if (this._hasMemorySource()) throw new p(Ue, `FeatureLayer (title: ${this.title}, id: ${this.id}) created using in-memory source cannot be cloned`);\n    return super.clone();\n  }\n  serviceSupportsSpatialReference(e) {\n    return !!this.loaded && (\"memory\" === this.source?.type || xe(this, e));\n  }\n  save(e) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      return _this21._debouncedSaveOperations(Ae.SAVE, e);\n    })();\n  }\n  saveAs(e, r) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      return _this22._debouncedSaveOperations(Ae.SAVE_AS, r, e);\n    })();\n  }\n  _readEditingEnabled(e, r, t) {\n    let i = e.layerDefinition?.capabilities;\n    return i ? this._hasEditingCapability(i) : (i = e.capabilities, r && \"web-map\" === t?.origin && !this._hasMemorySource() && i ? this._hasEditingCapability(i) : void 0);\n  }\n  _hasEditingCapability(e) {\n    return e.toLowerCase().split(\",\").map(e => e.trim()).includes(\"editing\");\n  }\n  _writeEditingEnabled(e, r, t, i) {\n    if (!e) {\n      const e = this.capabilities?.operations?.supportsSync ? \"Query,Sync\" : \"Query\";\n      c(\"layerDefinition.capabilities\", e, r), t && !i?.writeLayerSchema && (r.capabilities = e);\n    }\n  }\n  _getLayerDomain(e) {\n    const r = this.fieldsIndex.get(e);\n    return r ? r.domain : null;\n  }\n  _fetchFirstValidLayerId(e) {\n    return s(this.url, {\n      query: {\n        f: \"json\",\n        ...this.customParameters,\n        token: this.apiKey\n      },\n      responseType: \"json\",\n      signal: e\n    }).then(e => {\n      const r = e.data;\n      if (r) return this.findFirstValidLayerId(r);\n    });\n  }\n  initLayerProperties(e) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      return _this23._set(\"source\", e), e.sourceJSON && (_this23.sourceJSON = e.sourceJSON, _this23.read(e.sourceJSON, {\n        origin: \"service\",\n        portalItem: _this23.portalItem,\n        portal: _this23.portalItem?.portal,\n        url: _this23.parsedUrl\n      })), _this23._verifySource(), _this23._verifyFields(), Ie(_this23.renderer, _this23.fieldsIndex), Te(_this23.timeInfo, _this23.fieldsIndex), Me(_this23, {\n        origin: \"service\"\n      });\n    })();\n  }\n  hasDataChanged() {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      return we(_this24);\n    })();\n  }\n  fetchPublishingStatus() {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      const e = _this25.source;\n      return e?.fetchPublishingStatus ? e.fetchPublishingStatus() : \"unavailable\";\n    })();\n  }\n  _verifyFields() {\n    const e = this.parsedUrl?.path ?? \"undefined\";\n    this.objectIdField || console.log(\"FeatureLayer: 'objectIdField' property is not defined (url: \" + e + \")\"), this.isTable || this._hasMemorySource() || -1 !== e.search(/\\/FeatureServer\\//i) || this.fields?.some(e => \"geometry\" === e.type) || console.log(\"FeatureLayer: unable to find field of type 'geometry' in the layer 'fields' list. If you are using a map service layer, features will not have geometry (url: \" + e + \")\");\n  }\n  _fixTemplates(e, r) {\n    e && e.forEach(e => {\n      const t = e.prototype?.attributes;\n      t && r && delete t[r];\n    });\n  }\n  _verifySource() {\n    if (this._hasMemorySource()) {\n      if (this.url) throw new p(\"feature-layer:mixed-source-and-url\", \"FeatureLayer cannot be created with both an in-memory source and a url\");\n    } else if (!this.url) throw new p(\"feature-layer:source-or-url-required\", \"FeatureLayer requires either a url, a valid portal item or a source\");\n  }\n  _initMemorySource(e) {\n    e.forEach(e => {\n      e.layer = this, e.sourceLayer = this;\n    }), this.addHandles([e.on(\"after-add\", e => {\n      e.item.layer = this, e.item.sourceLayer = this;\n    }), e.on(\"after-remove\", e => {\n      e.item.layer = null, e.item.sourceLayer = null;\n    })], \"fl-source\");\n  }\n  _resetMemorySource(e) {\n    e.forEach(e => {\n      e.layer = null, e.sourceLayer = null;\n    }), this.removeHandles(\"fl-source\");\n  }\n  _hasMemorySource() {\n    return !(this.url || !this.source);\n  }\n  findFirstValidLayerId(e) {\n    return Array.isArray(e.layers) && e.layers.length > 0 ? e.layers[0].id : Array.isArray(e.tables) && e.tables.length > 0 ? e.tables[0].id : void 0;\n  }\n};\ne([S(\"service\", \"capabilities\")], Be.prototype, \"readCapabilities\", null), e([v({\n  json: {\n    origins: {\n      \"web-scene\": {\n        write: !1\n      }\n    },\n    write: !0\n  }\n})], Be.prototype, \"charts\", void 0), e([v({\n  readOnly: !0\n})], Be.prototype, \"createQueryVersion\", null), e([v({\n  json: {\n    read: {\n      source: \"layerDefinition.copyrightText\"\n    }\n  }\n})], Be.prototype, \"copyright\", void 0), e([v({\n  json: {\n    read: {\n      source: \"layerDefinition.displayField\"\n    }\n  }\n})], Be.prototype, \"displayField\", void 0), e([v({\n  types: a,\n  readOnly: !0\n})], Be.prototype, \"defaultSymbol\", void 0), e([v({\n  type: Pe\n})], Be.prototype, \"dynamicDataSource\", void 0), e([v({\n  type: Boolean\n})], Be.prototype, \"editingEnabled\", null), e([S([\"portal-item\", \"web-scene\"], \"editingEnabled\", [\"layerDefinition.capabilities\"])], Be.prototype, \"readEditingEnabled\", null), e([S(\"web-map\", \"editingEnabled\", [\"capabilities\", \"layerDefinition.capabilities\"])], Be.prototype, \"readEditingEnabledFromWebMap\", null), e([I([\"portal-item\", \"web-scene\"], \"editingEnabled\", {\n  \"layerDefinition.capabilities\": {\n    type: String\n  }\n})], Be.prototype, \"writeEditingEnabled\", null), e([I(\"web-map\", \"editingEnabled\", {\n  capabilities: {\n    type: String\n  },\n  \"layerDefinition.capabilities\": {\n    type: String\n  }\n})], Be.prototype, \"writeEditingEnabledToWebMap\", null), e([v({\n  readOnly: !0\n})], Be.prototype, \"effectiveEditingEnabled\", null), e([v({\n  ...Je.fields,\n  json: {\n    read: {\n      source: \"layerDefinition.fields\"\n    },\n    origins: {\n      service: {\n        name: \"fields\"\n      },\n      \"web-map\": {\n        write: {\n          target: \"layerDefinition.fields\",\n          overridePolicy: We\n        }\n      }\n    }\n  }\n})], Be.prototype, \"fields\", void 0), e([v(Je.fieldsIndex)], Be.prototype, \"fieldsIndex\", void 0), e([v({\n  type: E,\n  json: {\n    name: \"formInfo\",\n    write: !0,\n    origins: {\n      \"web-scene\": {\n        read: !1,\n        write: !1\n      }\n    }\n  }\n})], Be.prototype, \"formTemplate\", void 0), e([v({\n  json: {\n    read: {\n      source: \"layerDefinition.extent\"\n    }\n  }\n})], Be.prototype, \"fullExtent\", void 0), e([v({\n  json: {\n    origins: {\n      \"web-map\": {\n        write: {\n          target: \"layerDefinition.geometryType\",\n          overridePolicy: We,\n          writer(e, r, t) {\n            const i = e ? ve.toJSON(e) : null;\n            i && c(t, i, r);\n          }\n        }\n      }\n    },\n    read: {\n      source: \"layerDefinition.geometryType\",\n      reader: ve.read\n    }\n  }\n})], Be.prototype, \"geometryType\", void 0), e([v({\n  json: {\n    read: {\n      source: \"layerDefinition.hasM\"\n    }\n  }\n})], Be.prototype, \"hasM\", void 0), e([v({\n  json: {\n    read: {\n      source: \"layerDefinition.hasZ\"\n    }\n  }\n})], Be.prototype, \"hasZ\", void 0), e([v(H)], Be.prototype, \"id\", void 0), e([v({\n  readOnly: !0,\n  json: {\n    origins: {\n      service: {\n        read: !0\n      }\n    },\n    read: !1\n  }\n})], Be.prototype, \"infoFor3D\", void 0), e([v({\n  json: {\n    origins: {\n      \"web-map\": {\n        write: {\n          target: \"layerDefinition.type\"\n        }\n      }\n    }\n  }\n})], Be.prototype, \"isTable\", void 0), e([S(\"service\", \"isTable\", [\"type\", \"geometryType\"]), S(\"isTable\", [\"layerDefinition.type\", \"layerDefinition.geometryType\"])], Be.prototype, \"readIsTable\", null), e([I(\"web-map\", \"isTable\")], Be.prototype, \"writeIsTable\", null), e([v(k)], Be.prototype, \"labelsVisible\", void 0), e([v({\n  type: [Ee],\n  json: {\n    origins: {\n      service: {\n        name: \"drawingInfo.labelingInfo\",\n        read: De,\n        write: !1\n      },\n      \"web-scene\": {\n        name: \"layerDefinition.drawingInfo.labelingInfo\",\n        read: De,\n        write: {\n          enabled: !0,\n          layerContainerTypes: T\n        }\n      }\n    },\n    name: \"layerDefinition.drawingInfo.labelingInfo\",\n    read: De,\n    write: !0\n  }\n})], Be.prototype, \"labelingInfo\", void 0), e([v((() => {\n  const e = u(z);\n  return e.json.origins[\"portal-item\"] = {\n    write: {\n      target: \"layerDefinition.drawingInfo.transparency\",\n      writer(e, r, t) {\n        c(t, Ve(e), r);\n      }\n    }\n  }, e;\n})())], Be.prototype, \"opacity\", void 0), e([v(K)], Be.prototype, \"legendEnabled\", void 0), e([v({\n  type: [\"show\", \"hide\"],\n  json: (() => {\n    const e = u(X.json);\n    return e.origins[\"portal-item\"] = {\n      read: !1,\n      write: !1\n    }, e;\n  })()\n})], Be.prototype, \"listMode\", void 0), e([S(\"globalIdField\", [\"layerDefinition.globalIdField\", \"layerDefinition.fields\"])], Be.prototype, \"readGlobalIdField\", null), e([v({\n  json: {\n    origins: {\n      \"web-map\": {\n        write: {\n          target: \"layerDefinition.objectIdField\",\n          overridePolicy: We\n        }\n      }\n    }\n  }\n})], Be.prototype, \"objectIdField\", void 0), e([S(\"objectIdField\", [\"layerDefinition.objectIdField\", \"layerDefinition.fields\"])], Be.prototype, \"readObjectIdField\", null), e([v({\n  value: \"ArcGISFeatureLayer\",\n  type: [\"ArcGISFeatureLayer\"]\n})], Be.prototype, \"operationalLayerType\", void 0), e([v(Je.outFields)], Be.prototype, \"outFields\", void 0), e([v({\n  readOnly: !0\n})], Be.prototype, \"parsedUrl\", null), e([v({\n  type: String,\n  json: {\n    origins: {\n      \"web-scene\": {\n        read: !0,\n        write: !0\n      }\n    },\n    read: !1\n  }\n})], Be.prototype, \"path\", void 0), e([v(Y)], Be.prototype, \"popupEnabled\", void 0), e([v({\n  type: r,\n  json: {\n    name: \"popupInfo\",\n    write: !0\n  }\n})], Be.prototype, \"popupTemplate\", void 0), e([v({\n  readOnly: !0\n})], Be.prototype, \"defaultPopupTemplate\", null), e([v({\n  types: i,\n  json: {\n    origins: {\n      service: {\n        write: {\n          target: \"drawingInfo.renderer\",\n          enabled: !1\n        }\n      },\n      \"web-scene\": {\n        types: o,\n        name: \"layerDefinition.drawingInfo.renderer\",\n        write: {\n          layerContainerTypes: T,\n          overridePolicy: (e, r, t) => ({\n            ignoreOrigin: t?.writeLayerSchema\n          })\n        }\n      }\n    },\n    write: {\n      target: \"layerDefinition.drawingInfo.renderer\",\n      overridePolicy: (e, r, t) => ({\n        ignoreOrigin: t?.writeLayerSchema\n      })\n    }\n  }\n})], Be.prototype, \"renderer\", null), e([S(\"service\", \"renderer\", [\"drawingInfo.renderer\", \"defaultSymbol\"]), S(\"renderer\", [\"layerDefinition.drawingInfo.renderer\", \"layerDefinition.defaultSymbol\"])], Be.prototype, \"readRenderer\", null), e([v()], Be.prototype, \"resourceInfo\", void 0), e([v((() => {\n  const e = u(ee);\n  return e.json.origins[\"portal-item\"] = {\n    read: !1,\n    write: !1\n  }, e;\n})())], Be.prototype, \"screenSizePerspectiveEnabled\", void 0), e([v({\n  clonable: !1\n})], Be.prototype, \"source\", null), e([j(\"source\")], Be.prototype, \"castSource\", null), e([S(\"portal-item\", \"source\", [\"featureSet\"]), S(\"web-map\", \"source\", [\"featureSet\"])], Be.prototype, \"readSource\", null), e([v({\n  json: {\n    read: {\n      source: \"layerDefinition.extent.spatialReference\"\n    }\n  }\n})], Be.prototype, \"spatialReference\", void 0), e([v({\n  type: Number\n})], Be.prototype, \"subtypeCode\", void 0), e([v({\n  type: [je]\n})], Be.prototype, \"templates\", void 0), e([S(\"templates\", [\"editFieldsInfo\", \"creatorField\", \"editorField\", \"templates\"])], Be.prototype, \"readTemplates\", null), e([v({\n  type: _e\n})], Be.prototype, \"timeInfo\", void 0), e([v()], Be.prototype, \"title\", void 0), e([S(\"service\", \"title\", [\"name\"]), S(\"portal-item\", \"title\", [\"layerDefinition.title\", \"layerDefinition.name\", \"title\"])], Be.prototype, \"readTitle\", null), e([S(\"web-map\", \"title\", [\"layerDefinition.name\", \"title\"])], Be.prototype, \"readTitleFromWebMap\", null), e([v({\n  type: String\n})], Be.prototype, \"sublayerTitleMode\", void 0), e([v({\n  json: {\n    read: !1\n  }\n})], Be.prototype, \"type\", void 0), e([v({\n  type: String\n})], Be.prototype, \"typeIdField\", void 0), e([S(\"service\", \"typeIdField\"), S(\"typeIdField\", [\"layerDefinition.typeIdField\"])], Be.prototype, \"readTypeIdField\", null), e([v({\n  type: [Se]\n})], Be.prototype, \"types\", void 0), e([S(\"service\", \"types\", [\"types\"]), S(\"types\", [\"layerDefinition.types\"])], Be.prototype, \"readTypes\", null), e([v({\n  type: Boolean,\n  json: {\n    origins: {\n      \"portal-item\": {\n        write: {\n          target: \"layerDefinition.defaultVisibility\"\n        }\n      }\n    }\n  }\n})], Be.prototype, \"visible\", void 0), e([S(\"portal-item\", \"visible\", [\"visibility\", \"layerDefinition.defaultVisibility\"])], Be.prototype, \"readVisible\", null), Be = e([F(Qe)], Be);\nconst Ze = Be;\nexport { Ze as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}