{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.28/esri/copyright.txt for details.\n*/\nimport { _ as e } from \"../../chunks/tslib.es6.js\";\nimport { geometryTypes as t } from \"../../geometry.js\";\nimport r from \"../../Graphic.js\";\nimport { JSONMap as o } from \"../../core/jsonMap.js\";\nimport { JSONSupport as s } from \"../../core/JSONSupport.js\";\nimport { clone as n } from \"../../core/lang.js\";\nimport { property as i } from \"../../core/accessorSupport/decorators/property.js\";\nimport \"../../core/accessorSupport/ensureType.js\";\nimport { reader as l } from \"../../core/accessorSupport/decorators/reader.js\";\nimport { subclass as a } from \"../../core/accessorSupport/decorators/subclass.js\";\nimport { writer as p } from \"../../core/accessorSupport/decorators/writer.js\";\nimport m from \"../../geometry/SpatialReference.js\";\nimport { fromJSON as c, isPolygon as u } from \"../../geometry/support/jsonUtils.js\";\nimport y from \"../../layers/support/Field.js\";\nvar f;\nconst h = new o({\n  esriGeometryPoint: \"point\",\n  esriGeometryMultipoint: \"multipoint\",\n  esriGeometryPolyline: \"polyline\",\n  esriGeometryPolygon: \"polygon\",\n  esriGeometryEnvelope: \"extent\",\n  mesh: \"mesh\",\n  \"\": null\n});\nlet g = f = class extends s {\n  constructor(e) {\n    super(e), this.displayFieldName = null, this.exceededTransferLimit = !1, this.features = [], this.fields = null, this.geometryType = null, this.hasM = !1, this.hasZ = !1, this.queryGeometry = null, this.spatialReference = null;\n  }\n  readFeatures(e, t) {\n    const o = m.fromJSON(t.spatialReference),\n      s = [];\n    for (let n = 0; n < e.length; n++) {\n      const t = e[n],\n        i = r.fromJSON(t),\n        l = t.geometry?.spatialReference;\n      null == i.geometry || l || (i.geometry.spatialReference = o);\n      const a = t.aggregateGeometries,\n        p = i.aggregateGeometries;\n      if (a && null != p) for (const e in p) {\n        const t = p[e],\n          r = a[e],\n          s = r?.spatialReference;\n        null == t || s || (t.spatialReference = o);\n      }\n      s.push(i);\n    }\n    return s;\n  }\n  writeGeometryType(e, t, r, o) {\n    if (e) return void h.write(e, t, r, o);\n    const {\n      features: s\n    } = this;\n    if (s) for (const n of s) if (null != n?.geometry) return void h.write(n.geometry.type, t, r, o);\n  }\n  readQueryGeometry(e, t) {\n    if (!e) return null;\n    const r = !!e.spatialReference,\n      o = c(e);\n    return o && !r && t.spatialReference && (o.spatialReference = m.fromJSON(t.spatialReference)), o;\n  }\n  writeSpatialReference(e, t) {\n    if (e) return void (t.spatialReference = e.toJSON());\n    const {\n      features: r\n    } = this;\n    if (r) for (const o of r) if (o && null != o.geometry && o.geometry.spatialReference) return void (t.spatialReference = o.geometry.spatialReference.toJSON());\n  }\n  clone() {\n    return new f(this.cloneProperties());\n  }\n  cloneProperties() {\n    return n({\n      displayFieldName: this.displayFieldName,\n      exceededTransferLimit: this.exceededTransferLimit,\n      features: this.features,\n      fields: this.fields,\n      geometryType: this.geometryType,\n      hasM: this.hasM,\n      hasZ: this.hasZ,\n      queryGeometry: this.queryGeometry,\n      spatialReference: this.spatialReference,\n      transform: this.transform\n    });\n  }\n  toJSON(e) {\n    const t = this.write();\n    if (t.features && Array.isArray(e) && e.length > 0) for (let r = 0; r < t.features.length; r++) {\n      const o = t.features[r];\n      if (o.geometry) {\n        const t = e?.[r];\n        o.geometry = t?.toJSON() || o.geometry;\n      }\n    }\n    return t;\n  }\n  quantize(e) {\n    const {\n        scale: [t, r],\n        translate: [o, s]\n      } = e,\n      n = e => Math.round((e - o) / t),\n      i = e => Math.round((s - e) / r),\n      l = this.features,\n      a = this._getQuantizationFunction(this.geometryType, n, i);\n    for (let p = 0, m = l.length; p < m; p++) a?.(l[p].geometry) || (l.splice(p, 1), p--, m--);\n    return this.transform = e, this;\n  }\n  unquantize() {\n    const {\n      geometryType: e,\n      features: t,\n      transform: r\n    } = this;\n    if (!r) return this;\n    const {\n        translate: [o, s],\n        scale: [n, i]\n      } = r,\n      l = e => e * n + o,\n      a = e => s - e * i;\n    let p = null,\n      m = null;\n    if (this.hasZ && null != r?.scale?.[2]) {\n      const {\n        translate: [,, e],\n        scale: [,, t]\n      } = r;\n      p = r => r * t + e;\n    }\n    if (this.hasM && null != r?.scale?.[3]) {\n      const {\n        translate: [,,, e],\n        scale: [,,, t]\n      } = r;\n      m = r => null == r ? r : r * t + e;\n    }\n    const c = this._getHydrationFunction(e, l, a, p, m);\n    for (const {\n      geometry: u\n    } of t) null != u && c && c(u);\n    return this.transform = null, this;\n  }\n  _quantizePoints(e, t, r) {\n    let o, s;\n    const n = [];\n    for (let i = 0, l = e.length; i < l; i++) {\n      const l = e[i];\n      if (i > 0) {\n        const e = t(l[0]),\n          i = r(l[1]);\n        e === o && i === s || (n.push([e - o, i - s]), o = e, s = i);\n      } else o = t(l[0]), s = r(l[1]), n.push([o, s]);\n    }\n    return n.length > 0 ? n : null;\n  }\n  _getQuantizationFunction(e, t, r) {\n    return \"point\" === e ? e => (e.x = t(e.x), e.y = r(e.y), e) : \"polyline\" === e || \"polygon\" === e ? e => {\n      const o = u(e) ? e.rings : e.paths,\n        s = [];\n      for (let n = 0, i = o.length; n < i; n++) {\n        const e = o[n],\n          i = this._quantizePoints(e, t, r);\n        i && s.push(i);\n      }\n      return s.length > 0 ? (u(e) ? e.rings = s : e.paths = s, e) : null;\n    } : \"multipoint\" === e ? e => {\n      const o = this._quantizePoints(e.points, t, r);\n      return o && o.length > 0 ? (e.points = o, e) : null;\n    } : \"extent\" === e ? e => e : null;\n  }\n  _getHydrationFunction(e, t, r, o, s) {\n    return \"point\" === e ? e => {\n      e.x = t(e.x), e.y = r(e.y), o && (e.z = o(e.z));\n    } : \"polyline\" === e || \"polygon\" === e ? e => {\n      const n = u(e) ? e.rings : e.paths;\n      let i, l;\n      for (let o = 0, s = n.length; o < s; o++) {\n        const e = n[o];\n        for (let o = 0, s = e.length; o < s; o++) {\n          const s = e[o];\n          o > 0 ? (i += s[0], l += s[1]) : (i = s[0], l = s[1]), s[0] = t(i), s[1] = r(l);\n        }\n      }\n      if (o && s) for (let t = 0, r = n.length; t < r; t++) {\n        const e = n[t];\n        for (let t = 0, r = e.length; t < r; t++) {\n          const r = e[t];\n          r[2] = o(r[2]), r[3] = s(r[3]);\n        }\n      } else if (o) for (let t = 0, r = n.length; t < r; t++) {\n        const e = n[t];\n        for (let t = 0, r = e.length; t < r; t++) {\n          const r = e[t];\n          r[2] = o(r[2]);\n        }\n      } else if (s) for (let t = 0, r = n.length; t < r; t++) {\n        const e = n[t];\n        for (let t = 0, r = e.length; t < r; t++) {\n          const r = e[t];\n          r[2] = s(r[2]);\n        }\n      }\n    } : \"extent\" === e ? e => {\n      e.xmin = t(e.xmin), e.ymin = r(e.ymin), e.xmax = t(e.xmax), e.ymax = r(e.ymax), o && null != e.zmax && null != e.zmin && (e.zmax = o(e.zmax), e.zmin = o(e.zmin)), s && null != e.mmax && null != e.mmin && (e.mmax = s(e.mmax), e.mmin = s(e.mmin));\n    } : \"multipoint\" === e ? e => {\n      const n = e.points;\n      let i, l;\n      for (let o = 0, s = n.length; o < s; o++) {\n        const e = n[o];\n        o > 0 ? (i += e[0], l += e[1]) : (i = e[0], l = e[1]), e[0] = t(i), e[1] = r(l);\n      }\n      if (o && s) for (let t = 0, r = n.length; t < r; t++) {\n        const e = n[t];\n        e[2] = o(e[2]), e[3] = s(e[3]);\n      } else if (o) for (let t = 0, r = n.length; t < r; t++) {\n        const e = n[t];\n        e[2] = o(e[2]);\n      } else if (s) for (let t = 0, r = n.length; t < r; t++) {\n        const e = n[t];\n        e[2] = s(e[2]);\n      }\n    } : null;\n  }\n};\ne([i({\n  type: String,\n  json: {\n    write: !0\n  }\n})], g.prototype, \"displayFieldName\", void 0), e([i({\n  type: Boolean,\n  json: {\n    write: {\n      overridePolicy: e => ({\n        enabled: e\n      })\n    }\n  }\n})], g.prototype, \"exceededTransferLimit\", void 0), e([i({\n  type: [r],\n  json: {\n    write: !0\n  }\n})], g.prototype, \"features\", void 0), e([l(\"features\")], g.prototype, \"readFeatures\", null), e([i({\n  type: [y],\n  json: {\n    write: !0\n  }\n})], g.prototype, \"fields\", void 0), e([i({\n  type: [\"point\", \"multipoint\", \"polyline\", \"polygon\", \"extent\", \"mesh\"],\n  json: {\n    read: {\n      reader: h.read\n    }\n  }\n})], g.prototype, \"geometryType\", void 0), e([p(\"geometryType\")], g.prototype, \"writeGeometryType\", null), e([i({\n  type: Boolean,\n  json: {\n    write: {\n      overridePolicy: e => ({\n        enabled: e\n      })\n    }\n  }\n})], g.prototype, \"hasM\", void 0), e([i({\n  type: Boolean,\n  json: {\n    write: {\n      overridePolicy: e => ({\n        enabled: e\n      })\n    }\n  }\n})], g.prototype, \"hasZ\", void 0), e([i({\n  types: t,\n  json: {\n    write: !0\n  }\n})], g.prototype, \"queryGeometry\", void 0), e([l(\"queryGeometry\")], g.prototype, \"readQueryGeometry\", null), e([i({\n  type: m,\n  json: {\n    write: !0\n  }\n})], g.prototype, \"spatialReference\", void 0), e([p(\"spatialReference\")], g.prototype, \"writeSpatialReference\", null), e([i({\n  json: {\n    write: !0\n  }\n})], g.prototype, \"transform\", void 0), g = f = e([a(\"esri.rest.support.FeatureSet\")], g), g.prototype.toJSON.isDefaultToJSON = !0;\nconst d = g;\nexport { d as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}