{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.28/esri/copyright.txt for details.\n*/\nimport { _ as t } from \"./chunks/tslib.es6.js\";\nimport { geometryTypes as e } from \"./geometry.js\";\nimport r from \"./PopupTemplate.js\";\nimport { symbolTypes as s } from \"./symbols.js\";\nimport { ClonableMixin as o } from \"./core/Clonable.js\";\nimport { isSerializable as i, JSONSupport as a } from \"./core/JSONSupport.js\";\nimport { generateUID as l } from \"./core/uid.js\";\nimport { property as p } from \"./core/accessorSupport/decorators/property.js\";\nimport \"./core/accessorSupport/ensureType.js\";\nimport \"./core/arrayUtils.js\";\nimport \"./core/has.js\";\nimport { subclass as n } from \"./core/accessorSupport/decorators/subclass.js\";\nimport { fromJSON as u } from \"./geometry/support/jsonUtils.js\";\nvar y;\nfunction m(t) {\n  if (!t) return null;\n  const e = {};\n  for (const r in t) {\n    const s = u(t[r]);\n    s && (e[r] = s);\n  }\n  return 0 !== Object.keys(e).length ? e : null;\n}\nfunction g(t) {\n  if (null == t) return null;\n  const e = {};\n  for (const r in t) {\n    const s = t[r];\n    s && (e[r] = s.toJSON());\n  }\n  return 0 !== Object.keys(e).length ? e : null;\n}\nlet h = y = class extends o(a) {\n  constructor(...t) {\n    super(...t), this.isAggregate = !1, this.layer = null, this.popupTemplate = null, this.sourceLayer = null, Object.defineProperty(this, \"uid\", {\n      value: l(),\n      configurable: !0\n    });\n  }\n  normalizeCtorArgs(t, e, r, s) {\n    return t && !t.declaredClass ? t : {\n      geometry: t,\n      symbol: e,\n      attributes: r,\n      popupTemplate: s\n    };\n  }\n  set aggregateGeometries(t) {\n    const e = this._get(\"aggregateGeometries\");\n    JSON.stringify(e) !== JSON.stringify(t) && this._set(\"aggregateGeometries\", t);\n  }\n  set attributes(t) {\n    const e = this._get(\"attributes\");\n    e !== t && (this._set(\"attributes\", t), this._notifyLayer(\"attributes\", e, t));\n  }\n  set geometry(t) {\n    const e = this._get(\"geometry\");\n    e !== t && (this._set(\"geometry\", t), this._notifyLayer(\"geometry\", e, t));\n  }\n  set symbol(t) {\n    const e = this._get(\"symbol\");\n    e !== t && (this._set(\"symbol\", t), this._notifyLayer(\"symbol\", e, t));\n  }\n  set visible(t) {\n    const e = this._get(\"visible\");\n    e !== t && (this._set(\"visible\", t), this._notifyLayer(\"visible\", e, t));\n  }\n  cloneShallow() {\n    return new y({\n      aggregateGeometries: this.aggregateGeometries,\n      attributes: this.attributes,\n      geometry: this.geometry,\n      isAggregate: this.isAggregate,\n      layer: this.layer,\n      popupTemplate: this.popupTemplate,\n      sourceLayer: this.sourceLayer,\n      symbol: this.symbol,\n      visible: this.visible\n    });\n  }\n  getEffectivePopupTemplate(t = !1) {\n    if (this.popupTemplate) return this.popupTemplate;\n    for (const e of [this.sourceLayer, this.layer]) if (e) {\n      if (\"popupTemplate\" in e && e.popupTemplate) return e.popupTemplate;\n      if (t && \"defaultPopupTemplate\" in e && null != e.defaultPopupTemplate) return e.defaultPopupTemplate;\n    }\n    return null;\n  }\n  getAttribute(t) {\n    return this.attributes?.[t];\n  }\n  setAttribute(t, e) {\n    if (this.attributes) {\n      const r = this.getAttribute(t);\n      this.attributes[t] = e, this._notifyLayer(\"attributes\", r, e, t);\n    } else this.attributes = {\n      [t]: e\n    }, this._notifyLayer(\"attributes\", void 0, e, t);\n  }\n  getObjectId() {\n    return this.sourceLayer && \"objectIdField\" in this.sourceLayer && this.sourceLayer.objectIdField ? this.getAttribute(this.sourceLayer.objectIdField) : null;\n  }\n  toJSON() {\n    return {\n      aggregateGeometries: g(this.aggregateGeometries),\n      geometry: null != this.geometry ? this.geometry.toJSON() : null,\n      symbol: null != this.symbol ? this.symbol.toJSON() : null,\n      attributes: i(this.attributes) ? this.attributes.toJSON() : {\n        ...this.attributes\n      },\n      popupTemplate: this.popupTemplate?.toJSON() ?? null\n    };\n  }\n  notifyGeometryChanged() {\n    this._notifyLayer(\"geometry\", this.geometry, this.geometry);\n  }\n  notifyMeshTransformChanged(t = {}) {\n    const {\n      geometry: e\n    } = this;\n    if (\"mesh\" === e?.type) {\n      const r = {\n        origin: e.origin,\n        transform: e.transform\n      };\n      this._notifyLayer(\"origin-transform\", r, r, t.action);\n    }\n  }\n  _notifyLayer(t, e, r, s) {\n    if (!this.layer || !(\"graphicChanged\" in this.layer)) return;\n    const o = {\n      graphic: this,\n      property: t,\n      oldValue: e,\n      newValue: r\n    };\n    \"origin-transform\" === t && (o.action = s), \"attributes\" === t && (o.attributeName = s), this.layer.graphicChanged(o);\n  }\n};\nt([p({\n  value: null,\n  json: {\n    read: m\n  }\n})], h.prototype, \"aggregateGeometries\", null), t([p({\n  value: null\n})], h.prototype, \"attributes\", null), t([p({\n  value: null,\n  types: e,\n  json: {\n    read: u\n  }\n})], h.prototype, \"geometry\", null), t([p({\n  type: Boolean\n})], h.prototype, \"isAggregate\", void 0), t([p({\n  clonable: \"reference\"\n})], h.prototype, \"layer\", void 0), t([p({\n  type: r\n})], h.prototype, \"popupTemplate\", void 0), t([p({\n  clonable: \"reference\"\n})], h.prototype, \"sourceLayer\", void 0), t([p({\n  value: null,\n  types: s\n})], h.prototype, \"symbol\", null), t([p({\n  type: Boolean,\n  value: !0\n})], h.prototype, \"visible\", null), h = y = t([n(\"esri.Graphic\")], h), function (t) {\n  t.generateUID = l;\n}(h || (h = {}));\nconst c = h;\nexport { c as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}