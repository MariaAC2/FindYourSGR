{"ast":null,"code":"import _asyncToGenerator from \"/home/alex/FindYourSGR/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.28/esri/copyright.txt for details.\n*/\nimport e from \"../request.js\";\nimport { get as r } from \"../core/accessorSupport/get.js\";\nimport { normalizeCentralMeridian as t } from \"../geometry/support/normalizeUtils.js\";\nimport { collectGeometries as s, isInputGeometryZAware as o, fetchServiceDescription as a, dropZValuesOffInputGeometry as i } from \"./networkService.js\";\nimport { parseUrl as n } from \"./utils.js\";\nimport { routeParametersToQueryParameters as u } from \"./route/utils.js\";\nimport f from \"./support/FeatureSet.js\";\nimport p from \"./support/RouteSolveResult.js\";\nfunction c(e) {\n  return e instanceof f;\n}\nfunction l(_x, _x2, _x3) {\n  return _l.apply(this, arguments);\n}\nfunction _l() {\n  _l = _asyncToGenerator(function* (f, p, l) {\n    const y = [],\n      d = [],\n      g = {},\n      h = {},\n      R = n(f),\n      {\n        path: v\n      } = R;\n    c(p.stops) && s(p.stops.features, d, \"stops.features\", g), c(p.pointBarriers) && s(p.pointBarriers.features, d, \"pointBarriers.features\", g), c(p.polylineBarriers) && s(p.polylineBarriers.features, d, \"polylineBarriers.features\", g), c(p.polygonBarriers) && s(p.polygonBarriers.features, d, \"polygonBarriers.features\", g);\n    const B = yield t(d);\n    for (const e in g) {\n      const r = g[e];\n      y.push(e), h[e] = B.slice(r[0], r[1]);\n    }\n    if (o(h, y)) {\n      let e = null;\n      try {\n        e = yield a(v, p.apiKey, l);\n      } catch {}\n      e && !e.hasZ && i(h, y);\n    }\n    for (const e in h) h[e].forEach((t, s) => {\n      r(p, e)[s].geometry = t;\n    });\n    const E = {\n        ...l,\n        query: {\n          ...R.query,\n          ...u(p),\n          f: \"json\"\n        }\n      },\n      T = v.endsWith(\"/solve\") ? v : `${v}/solve`,\n      {\n        data: b\n      } = yield e(T, E);\n    return m(b);\n  });\n  return _l.apply(this, arguments);\n}\nfunction m(e) {\n  const {\n      barriers: r,\n      directionLines: t,\n      directionPoints: s,\n      directions: o,\n      messages: a,\n      polygonBarriers: i,\n      polylineBarriers: n,\n      routes: u,\n      stops: f,\n      traversedEdges: c,\n      traversedJunctions: l,\n      traversedTurns: m\n    } = e,\n    y = e => {\n      const r = g.find(r => r.routeName === e);\n      if (null != r) return r;\n      const t = {\n        routeId: g.length + 1,\n        routeName: e\n      };\n      return g.push(t), t;\n    },\n    d = e => {\n      const r = g.find(r => r.routeId === e);\n      if (null != r) return r;\n      const t = {\n        routeId: e,\n        routeName: null\n      };\n      return g.push(t), t;\n    },\n    g = [];\n  u?.features.forEach((e, r) => {\n    e.geometry.spatialReference = u.spatialReference ?? void 0;\n    const t = e.attributes.Name,\n      s = r + 1;\n    g.push({\n      routeId: s,\n      routeName: t,\n      route: e\n    });\n  }), o?.forEach(e => {\n    const {\n      routeName: r\n    } = e;\n    y(r).directions = e;\n  });\n  const h = (f?.features.every(e => null == e.attributes.RouteName) ?? !1) && g.length > 0 ? g[0].routeName : null;\n  return f?.features.forEach(e => {\n    e.geometry && (e.geometry.spatialReference ??= f.spatialReference ?? void 0);\n    const r = h ?? e.attributes.RouteName,\n      t = y(r);\n    t.stops ??= [], t.stops.push(e);\n  }), t?.features.forEach(e => {\n    const r = e.attributes.RouteID,\n      s = d(r),\n      {\n        geometryType: o,\n        spatialReference: a\n      } = t;\n    s.directionLines ??= {\n      features: [],\n      geometryType: o,\n      spatialReference: a\n    }, s.directionLines.features.push(e);\n  }), s?.features.forEach(e => {\n    const r = e.attributes.RouteID,\n      t = d(r),\n      {\n        geometryType: o,\n        spatialReference: a\n      } = s;\n    t.directionPoints ??= {\n      features: [],\n      geometryType: o,\n      spatialReference: a\n    }, t.directionPoints.features.push(e);\n  }), c?.features.forEach(e => {\n    const r = e.attributes.RouteID,\n      t = d(r),\n      {\n        geometryType: s,\n        spatialReference: o\n      } = c;\n    t.traversedEdges ??= {\n      features: [],\n      geometryType: s,\n      spatialReference: o\n    }, t.traversedEdges.features.push(e);\n  }), l?.features.forEach(e => {\n    const r = e.attributes.RouteID,\n      t = d(r),\n      {\n        geometryType: s,\n        spatialReference: o\n      } = l;\n    t.traversedJunctions ??= {\n      features: [],\n      geometryType: s,\n      spatialReference: o\n    }, t.traversedJunctions.features.push(e);\n  }), m?.features.forEach(e => {\n    const r = e.attributes.RouteID,\n      t = d(r);\n    t.traversedTurns ??= {\n      features: []\n    }, t.traversedTurns.features.push(e);\n  }), p.fromJSON({\n    routeResults: g,\n    barriers: r,\n    polygonBarriers: i,\n    polylineBarriers: n,\n    messages: a\n  });\n}\nexport { l as solve };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}