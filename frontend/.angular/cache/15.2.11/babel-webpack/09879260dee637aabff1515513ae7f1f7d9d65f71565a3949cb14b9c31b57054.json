{"ast":null,"code":"import _asyncToGenerator from \"/home/alex/FindYourSGR/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.28/esri/copyright.txt for details.\n*/\nimport e from \"./config.js\";\nimport { id as t } from \"./kernel.js\";\nimport r from \"./core/Error.js\";\nimport has from \"./core/has.js\";\nimport { clone as s } from \"./core/lang.js\";\nimport { onAbort as o, isAbortError as a, createAbortError as n, isAborted as i } from \"./core/promiseUtils.js\";\nimport { queryToObject as l, isDataProtocol as u, isBlobProtocol as c, normalize as d, getInterceptor as p, isTrustedServer as h, getOrigin as m, toHTTPS as f, addQueryParameter as y, objectToQuery as w, getProxyRule as g, getProxyUrl as b, addQueryParameters as q, hasSameOrigin as T, getAppUrl as S, addProxyRule as k } from \"./core/urlUtils.js\";\nimport { isSecureProxyService as O } from \"./portal/support/urlUtils.js\";\nimport { supportsApiKey as C } from \"./support/apiKeyUtils.js\";\nimport { registerNoCorsDomains as v, isNoCorsRequestRequired as x, sendNoCorsRequest as L, createTimeoutError as E, loadImageAsync as U } from \"./support/requestUtils.js\";\nfunction j(_x, _x2) {\n  return _j.apply(this, arguments);\n}\nfunction _j() {\n  _j = _asyncToGenerator(function* (e, t) {\n    e instanceof URL && (e = e.toString()), t?.query instanceof URLSearchParams && (t.query = l(t.query.toString().replaceAll(\"+\", \" \")));\n    const r = u(e),\n      s = c(e);\n    s || r || (e = d(e));\n    const a = {\n      url: e,\n      requestOptions: {\n        ...t\n      }\n    };\n    let n = p(e);\n    if (n) {\n      const e = yield J(n, a);\n      if (null != e) return {\n        data: e,\n        getHeader: R,\n        httpStatus: 200,\n        requestOptions: a.requestOptions,\n        url: a.url\n      };\n      n.after || n.error || (n = null);\n    }\n    if (e = a.url, \"image\" === (t = a.requestOptions).responseType && (has(\"host-webworker\") || has(\"host-node\"))) throw B(\"request:invalid-parameters\", new Error(\"responseType 'image' is not supported in Web Workers or Node environment\"), a);\n    if (\"head\" === t.method) {\n      if (t.body) throw B(\"request:invalid-parameters\", new Error(\"body parameter cannot be set when method is 'head'\"), a);\n      if (r || s) throw B(\"request:invalid-parameters\", new Error(\"data and blob URLs are not supported for method 'head'\"), a);\n    }\n    if (yield $(), P) return P.execute(e, t);\n    const i = new AbortController();\n    o(t, () => i.abort());\n    const h = {\n        controller: i,\n        credential: void 0,\n        credentialToken: void 0,\n        fetchOptions: void 0,\n        hasToken: !1,\n        interceptor: n,\n        params: a,\n        redoRequest: !1,\n        useIdentity: D.useIdentity,\n        useProxy: !1,\n        useSSL: !1,\n        withCredentials: !1\n      },\n      m = yield V(h);\n    return n?.after?.(m), m;\n  });\n  return _j.apply(this, arguments);\n}\nlet P;\nconst D = e.request,\n  _ = \"FormData\" in globalThis,\n  A = new Set([499, 498, 403, 401]),\n  F = new Set([\"COM_0056\", \"COM_0057\", \"SB_0008\"]),\n  I = [/\\/arcgis\\/tokens/i, /\\/sharing(\\/rest)?\\/generatetoken/i, /\\/rest\\/info/i],\n  R = () => null,\n  M = Symbol();\nfunction H(e) {\n  const t = m(e);\n  t && !j._corsServers.includes(t) && j._corsServers.push(t);\n}\nfunction N(e) {\n  const t = m(e);\n  return !t || t.endsWith(\".arcgis.com\") || j._corsServers.includes(t) || h(t);\n}\nfunction B(e, t, o, i) {\n  let l = \"Error\";\n  const u = {\n    url: o.url,\n    requestOptions: o.requestOptions,\n    getHeader: R,\n    ssl: !1\n  };\n  if (t instanceof r) return t.details ? (t.details = s(t.details), t.details.url = o.url, t.details.requestOptions = o.requestOptions) : t.details = u, t;\n  if (t) {\n    const e = i && (e => i.headers.get(e)),\n      r = i?.status,\n      s = t.message;\n    s && (l = s), e && (u.getHeader = e), u.httpStatus = (null != t.httpCode ? t.httpCode : t.code) || r || 0, u.subCode = t.subcode, u.messageCode = t.messageCode, \"string\" == typeof t.details ? u.messages = [t.details] : u.messages = t.details, u.raw = M in t ? t[M] : t;\n  }\n  return a(t) ? n() : new r(e, l, u);\n}\nfunction $() {\n  return _$.apply(this, arguments);\n}\nfunction _$() {\n  _$ = _asyncToGenerator(function* () {\n    has(\"host-webworker\") ? P || (P = yield import(\"./core/workers/request.js\")) : j._abortableFetch || (j._abortableFetch = globalThis.fetch.bind(globalThis));\n  });\n  return _$.apply(this, arguments);\n}\nfunction z() {\n  return _z.apply(this, arguments);\n}\nfunction _z() {\n  _z = _asyncToGenerator(function* () {\n    t || (yield import(\"./identity/IdentityManager.js\"));\n  });\n  return _z.apply(this, arguments);\n}\nfunction K(_x3) {\n  return _K.apply(this, arguments);\n}\nfunction _K() {\n  _K = _asyncToGenerator(function* (r) {\n    const s = r.params.url,\n      o = r.params.requestOptions,\n      a = r.controller.signal,\n      n = o.body;\n    let l = null,\n      u = null;\n    if (_ && \"HTMLFormElement\" in globalThis && (n instanceof FormData ? l = n : n instanceof HTMLFormElement && (l = new FormData(n))), \"string\" == typeof n && (u = n), r.fetchOptions = {\n      cache: o.cacheBust && !(\"polyfill\" in j._abortableFetch) ? \"no-cache\" : \"default\",\n      credentials: \"same-origin\",\n      headers: o.headers || {},\n      method: \"head\" === o.method ? \"HEAD\" : \"GET\",\n      mode: \"cors\",\n      priority: D.priority,\n      redirect: \"follow\",\n      signal: a\n    }, (l || u) && (r.fetchOptions.body = l || u), \"anonymous\" === o.authMode && (r.useIdentity = !1), r.hasToken = !!(/token=/i.test(s) || o.query?.token || l?.get(\"token\")), !r.hasToken && e.apiKey && C(s) && (o.query || (o.query = {}), o.query.token = e.apiKey, r.hasToken = !0), r.useIdentity && !r.hasToken && !r.credentialToken && !W(s) && !i(a)) {\n      let e;\n      \"immediate\" === o.authMode ? (yield z(), e = yield t.getCredential(s, {\n        signal: a\n      }), r.credential = e) : \"no-prompt\" === o.authMode ? (yield z(), e = yield t.getCredential(s, {\n        prompt: !1,\n        signal: a\n      }).catch(() => {}), r.credential = e) : t && (e = t.findCredential(s)), e && (r.credentialToken = e.token, r.useSSL = !!e.ssl);\n    }\n  });\n  return _K.apply(this, arguments);\n}\nfunction W(e) {\n  return I.some(t => t.test(e));\n}\nfunction G(_x4) {\n  return _G.apply(this, arguments);\n}\nfunction _G() {\n  _G = _asyncToGenerator(function* (e) {\n    let r = e.params.url;\n    const s = e.params.requestOptions,\n      o = e.fetchOptions ?? {},\n      a = c(r) || u(r),\n      i = s.responseType || \"json\",\n      l = a ? 0 : null != s.timeout ? s.timeout : D.timeout;\n    let d = !1;\n    if (!a) {\n      e.useSSL && (r = f(r)), s.cacheBust && \"default\" === o.cache && (r = y(r, \"request.preventCache\", Date.now()));\n      let a = {\n        ...s.query\n      };\n      e.credentialToken && (a.token = e.credentialToken);\n      let n = w(a);\n      has(\"esri-url-encodes-apostrophe\") && (n = n.replaceAll(\"'\", \"%27\"));\n      const i = r.length + 1 + n.length;\n      let l;\n      d = \"delete\" === s.method || \"post\" === s.method || \"put\" === s.method || !!s.body || i > D.maxUrlLength;\n      const u = s.useProxy || !!g(r);\n      if (u) {\n        const e = b(r);\n        l = e.path, !d && l.length + 1 + i > D.maxUrlLength && (d = !0), e.query && (a = {\n          ...e.query,\n          ...a\n        });\n      }\n      if (\"HEAD\" === o.method && (d || u)) {\n        if (d) {\n          if (i > D.maxUrlLength) throw B(\"request:invalid-parameters\", new Error(\"URL exceeds maximum length\"), e.params);\n          throw B(\"request:invalid-parameters\", new Error(\"cannot use POST request when method is 'head'\"), e.params);\n        }\n        if (u) throw B(\"request:invalid-parameters\", new Error(\"cannot use proxy when method is 'head'\"), e.params);\n      }\n      if (d ? (o.method = \"delete\" === s.method ? \"DELETE\" : \"put\" === s.method ? \"PUT\" : \"POST\", s.body ? r = q(r, a) : (o.body = w(a), o.headers || (o.headers = {}), o.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\")) : r = q(r, a), u && (e.useProxy = !0, r = `${l}?${r}`), a.token && _ && o.body instanceof FormData && !O(r) && o.body.set(\"token\", a.token), s.hasOwnProperty(\"withCredentials\")) e.withCredentials = s.withCredentials;else if (!T(r, S())) if (h(r)) e.withCredentials = !0;else if (t) {\n        const s = t.findServerInfo(r);\n        s?.webTierAuth && (e.withCredentials = !0);\n      }\n      e.withCredentials && (o.credentials = \"include\", x(r) && (yield L(d ? q(r, a) : r)));\n    }\n    let p,\n      C,\n      v = 0,\n      U = !1;\n    l > 0 && (v = setTimeout(() => {\n      U = !0, e.controller.abort();\n    }, l));\n    try {\n      if (\"native-request-init\" === s.responseType) C = o, C.url = r;else if (\"image\" !== s.responseType || \"default\" !== o.cache || \"GET\" !== o.method || d || X(s.headers) || !a && !e.useProxy && D.proxyUrl && !N(r)) {\n        if (p = yield j._abortableFetch(r, o), e.useProxy || H(r), \"native\" === s.responseType) C = p;else if (\"HEAD\" !== o.method) if (p.ok) {\n          switch (i) {\n            case \"array-buffer\":\n              C = yield p.arrayBuffer();\n              break;\n            case \"blob\":\n            case \"image\":\n              C = yield p.blob();\n              break;\n            default:\n              C = yield p.text();\n          }\n          if (v && (clearTimeout(v), v = 0), \"json\" === i || \"xml\" === i || \"document\" === i) if (C) switch (i) {\n            case \"json\":\n              C = JSON.parse(C);\n              break;\n            case \"xml\":\n              C = Q(C, \"application/xml\");\n              break;\n            case \"document\":\n              C = Q(C, \"text/html\");\n          } else C = null;\n          if (C) {\n            if (\"array-buffer\" === i || \"blob\" === i) {\n              const e = p.headers.get(\"Content-Type\");\n              if (e && /application\\/json|text\\/plain/i.test(e) && C[\"blob\" === i ? \"size\" : \"byteLength\"] <= 750) try {\n                const e = yield new Response(C).json();\n                e.error && (C = e);\n              } catch {}\n            }\n            \"image\" === i && C instanceof Blob && (C = yield Z(URL.createObjectURL(C), e, !0));\n          }\n        } else {\n          C = yield p.text();\n          try {\n            C = JSON.parse(C);\n          } catch {}\n        }\n      } else C = yield Z(r, e);\n    } catch (P) {\n      if (\"AbortError\" === P.name) {\n        if (U) throw E();\n        throw n(\"Request canceled\");\n      }\n      if (!(!p && P instanceof TypeError && D.proxyUrl) || s.body || \"delete\" === s.method || \"head\" === s.method || \"post\" === s.method || \"put\" === s.method || e.useProxy || N(r)) throw P;\n      e.redoRequest = !0, k({\n        proxyUrl: D.proxyUrl,\n        urlPrefix: m(r) ?? \"\"\n      });\n    } finally {\n      v && clearTimeout(v);\n    }\n    return [p, C];\n  });\n  return _G.apply(this, arguments);\n}\nfunction J(_x5, _x6) {\n  return _J.apply(this, arguments);\n}\nfunction _J() {\n  _J = _asyncToGenerator(function* (e, t) {\n    if (null != e.responseData) return e.responseData;\n    if (e.headers && (t.requestOptions.headers = {\n      ...t.requestOptions.headers,\n      ...e.headers\n    }), e.query && (t.requestOptions.query = {\n      ...t.requestOptions.query,\n      ...e.query\n    }), e.before) {\n      let o, a;\n      try {\n        a = yield e.before(t);\n      } catch (s) {\n        o = B(\"request:interceptor\", s, t);\n      }\n      if ((a instanceof Error || a instanceof r) && (o = B(\"request:interceptor\", a, t)), o) throw e.error && e.error(o), o;\n      return a;\n    }\n  });\n  return _J.apply(this, arguments);\n}\nfunction X(e) {\n  if (e) for (const t of Object.getOwnPropertyNames(e)) if (e[t]) return !0;\n  return !1;\n}\nfunction Q(e, t) {\n  let r;\n  try {\n    r = new DOMParser().parseFromString(e, t);\n  } catch {}\n  if (!r || r.getElementsByTagName(\"parsererror\").length) throw new SyntaxError(\"XML Parse error\");\n  return r;\n}\nfunction V(_x7) {\n  return _V.apply(this, arguments);\n}\nfunction _V() {\n  _V = _asyncToGenerator(function* (e) {\n    let r, s;\n    yield K(e);\n    try {\n      do {\n        [r, s] = yield G(e);\n      } while (!(yield Y(e, r, s)));\n    } catch (n) {\n      const t = B(\"request:server\", n, e.params, r);\n      throw t.details.ssl = e.useSSL, e.interceptor?.error && e.interceptor.error(t), t;\n    }\n    const o = e.params.url;\n    if (s && /\\/sharing\\/rest\\/(accounts|portals)\\/self/i.test(o)) {\n      if (!e.hasToken && !e.credentialToken && s.user?.username && !h(o)) {\n        const e = m(o, !0);\n        e && D.trustedServers.push(e);\n      }\n      Array.isArray(s.authorizedCrossOriginNoCorsDomains) && v(s.authorizedCrossOriginNoCorsDomains);\n    }\n    const a = e.credential;\n    if (a && t) {\n      const e = t.findServerInfo(a.server);\n      let r = e?.owningSystemUrl;\n      if (r) {\n        r = r.replace(/\\/?$/, \"/sharing\");\n        const e = t.findCredential(r, a.userId);\n        e && -1 === t._getIdenticalSvcIdx(r, e) && e.resources.unshift(r);\n      }\n    }\n    return {\n      data: s,\n      getHeader: r ? e => r?.headers.get(e) : R,\n      httpStatus: r?.status ?? 200,\n      requestOptions: e.params.requestOptions,\n      ssl: e.useSSL,\n      url: e.params.url\n    };\n  });\n  return _V.apply(this, arguments);\n}\nfunction Y(_x8, _x9, _x10) {\n  return _Y.apply(this, arguments);\n}\nfunction _Y() {\n  _Y = _asyncToGenerator(function* (e, r, s) {\n    if (e.redoRequest) return e.redoRequest = !1, !1;\n    const o = e.params.requestOptions;\n    if (!r || \"native\" === o.responseType || \"native-request-init\" === o.responseType) return !0;\n    let a, n;\n    if (s && (s.error ? a = s.error : \"error\" === s.status && Array.isArray(s.messages) && (a = {\n      ...s\n    }, a[M] = s, a.details = s.messages)), !a && !r.ok) throw a = new Error(`Unable to load ${r.url} status: ${r.status}`), a[M] = s, a;\n    let i,\n      l = null;\n    a && (n = Number(a.code), l = a.hasOwnProperty(\"subcode\") ? Number(a.subcode) : null, i = a.messageCode, i = i?.toUpperCase());\n    const u = o.authMode;\n    if (403 === n && (4 === l || a.message?.toLowerCase().includes(\"ssl\") && !a.message.toLowerCase().includes(\"permission\"))) {\n      if (!e.useSSL) return e.useSSL = !0, !1;\n    } else if (!e.hasToken && e.useIdentity && (\"no-prompt\" !== u || 498 === n) && void 0 !== n && A.has(n) && !W(e.params.url) && (403 !== n || (!i || !F.has(i)) && (null == l || 2 === l && e.credentialToken))) {\n      yield z();\n      try {\n        const r = yield t.getCredential(e.params.url, {\n          error: B(\"request:server\", a, e.params),\n          prompt: \"no-prompt\" !== u,\n          signal: e.controller.signal,\n          token: e.credentialToken\n        });\n        return e.credential = r, e.credentialToken = r.token, e.useSSL = e.useSSL || r.ssl, !1;\n      } catch (c) {\n        if (\"no-prompt\" === u) return e.credential = void 0, e.credentialToken = void 0, !1;\n        a = c;\n      }\n    }\n    if (a) throw a;\n    return !0;\n  });\n  return _Y.apply(this, arguments);\n}\nfunction Z(e, t, r = !1) {\n  const s = t.controller.signal,\n    o = new Image();\n  return t.withCredentials ? o.crossOrigin = \"use-credentials\" : o.crossOrigin = \"anonymous\", o.alt = \"\", o.fetchPriority = D.priority, o.src = e, U(o, e, r, s);\n}\nj._abortableFetch = null, j._corsServers = [\"https://server.arcgisonline.com\", \"https://services.arcgisonline.com\"];\nexport { j as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}