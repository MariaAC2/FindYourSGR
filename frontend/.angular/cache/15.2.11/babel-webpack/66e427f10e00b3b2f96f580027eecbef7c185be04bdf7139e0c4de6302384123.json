{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.28/esri/copyright.txt for details.\n*/\nimport { _ as t } from \"../chunks/tslib.es6.js\";\nimport { clone as e } from \"../core/lang.js\";\nimport { property as s } from \"../core/accessorSupport/decorators/property.js\";\nimport \"../core/accessorSupport/ensureType.js\";\nimport { subclass as r } from \"../core/accessorSupport/decorators/subclass.js\";\nimport { writer as i } from \"../core/accessorSupport/decorators/writer.js\";\nimport a from \"./Extent.js\";\nimport n from \"./Geometry.js\";\nimport o from \"./Point.js\";\nimport h from \"./SpatialReference.js\";\nimport { getPolylineExtent as p } from \"./support/extentUtils.js\";\nimport { updateSupportFromPoint as l } from \"./support/zmUtils.js\";\nvar c;\nfunction u(t) {\n  return !Array.isArray(t[0]);\n}\nlet f = c = class extends n {\n  constructor(...t) {\n    super(...t), this.paths = [], this.type = \"polyline\";\n  }\n  normalizeCtorArgs(t, e) {\n    let s,\n      r,\n      i = null,\n      a = null;\n    return t && !Array.isArray(t) ? (i = t.paths ?? null, e || (t.spatialReference ? e = t.spatialReference : t.paths || (e = t)), s = t.hasZ, r = t.hasM) : i = t, i = i || [], e = e || h.WGS84, i.length && null != i[0]?.[0] && \"number\" == typeof i[0][0] && (i = [i]), a = i[0]?.[0], a && (void 0 === s && void 0 === r ? (s = a.length > 2, r = !1) : void 0 === s ? s = !r && a.length > 3 : void 0 === r && (r = !s && a.length > 3)), {\n      paths: i,\n      spatialReference: e,\n      hasZ: s,\n      hasM: r\n    };\n  }\n  get cache() {\n    return this.commitProperty(\"paths\"), this.commitProperty(\"hasZ\"), this.commitProperty(\"hasM\"), this.commitProperty(\"spatialReference\"), {};\n  }\n  get extent() {\n    const {\n        spatialReference: t\n      } = this,\n      e = p(this);\n    if (!e) return null;\n    const s = new a(e);\n    return s.spatialReference = t, s;\n  }\n  writePaths(t, s) {\n    s.paths = e(this.paths);\n  }\n  addPath(t) {\n    if (!t) return;\n    const e = this.paths,\n      s = e.length;\n    if (u(t)) {\n      const r = [];\n      for (let e = 0, s = t.length; e < s; e++) r[e] = t[e].toArray();\n      e[s] = r;\n    } else e[s] = t.concat();\n    return this.notifyChange(\"paths\"), this;\n  }\n  clone() {\n    const t = new c();\n    return t.spatialReference = this.spatialReference, t.paths = e(this.paths), t.hasZ = this.hasZ, t.hasM = this.hasM, t;\n  }\n  getPoint(t, e) {\n    if (!this._validateInputs(t, e)) return null;\n    const s = this.paths[t][e],\n      r = this.hasZ,\n      i = this.hasM;\n    return r && !i ? new o(s[0], s[1], s[2], void 0, this.spatialReference) : i && !r ? new o(s[0], s[1], void 0, s[2], this.spatialReference) : r && i ? new o(s[0], s[1], s[2], s[3], this.spatialReference) : new o(s[0], s[1], this.spatialReference);\n  }\n  insertPoint(t, e, s) {\n    return this._validateInputs(t, e, !0) ? (l(this, s), Array.isArray(s) || (s = s.toArray()), this.paths[t].splice(e, 0, s), this.notifyChange(\"paths\"), this) : this;\n  }\n  removePath(t) {\n    if (!this._validateInputs(t, null)) return null;\n    const e = this.paths.splice(t, 1)[0],\n      s = this.spatialReference,\n      r = e.map(t => new o(t, s));\n    return this.notifyChange(\"paths\"), r;\n  }\n  removePoint(t, e) {\n    if (!this._validateInputs(t, e)) return null;\n    const s = new o(this.paths[t].splice(e, 1)[0], this.spatialReference);\n    return this.notifyChange(\"paths\"), s;\n  }\n  setPoint(t, e, s) {\n    return this._validateInputs(t, e) ? (l(this, s), Array.isArray(s) || (s = s.toArray()), this.paths[t][e] = s, this.notifyChange(\"paths\"), this) : this;\n  }\n  _validateInputs(t, e, s = !1) {\n    if (null == t || t < 0 || t >= this.paths.length) return !1;\n    if (null != e) {\n      const r = this.paths[t];\n      if (s && (e < 0 || e > r.length)) return !1;\n      if (!s && (e < 0 || e >= r.length)) return !1;\n    }\n    return !0;\n  }\n  toJSON(t) {\n    return this.write({}, t);\n  }\n};\nt([s({\n  readOnly: !0\n})], f.prototype, \"cache\", null), t([s({\n  readOnly: !0\n})], f.prototype, \"extent\", null), t([s({\n  type: [[[Number]]],\n  json: {\n    write: {\n      isRequired: !0\n    }\n  }\n})], f.prototype, \"paths\", void 0), t([i(\"paths\")], f.prototype, \"writePaths\", null), f = c = t([r(\"esri.geometry.Polyline\")], f), f.prototype.toJSON.isDefaultToJSON = !0;\nconst m = f;\nexport { m as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}