{"ast":null,"code":"import _asyncToGenerator from \"/home/alex/FindYourSGR/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.28/esri/copyright.txt for details.\n*/\nimport e from \"../request.js\";\nimport r from \"../core/Error.js\";\nimport t from \"../core/Logger.js\";\nimport { getDeepValue as o } from \"../core/object.js\";\nimport { removeTrailingSlash as s } from \"../core/urlUtils.js\";\nimport { asValidOptions as a, parseUrl as n } from \"./utils.js\";\nimport i from \"./support/NetworkServiceDescription.js\";\nconst l = t.getLogger(\"esri.rest.networkService\");\nfunction u(e, r, t, o) {\n  o[t] = [r.length, r.length + e.length], e.forEach(e => {\n    r.push(e.geometry);\n  });\n}\nfunction f(e, r) {\n  for (let t = 0; t < r.length; t++) {\n    const o = e[r[t]];\n    if (o && o.length) for (const e of o) e.z = void 0;\n  }\n  l.warnOnce(\"The remote Network Analysis service is powered by a network dataset which is not Z-aware.\\nZ-coordinates of the input geometry are ignored.\");\n}\nfunction c(e, r) {\n  for (let t = 0; t < r.length; t++) {\n    const o = e[r[t]];\n    if (o && o.length) for (const e of o) if (null != e && e.hasZ) return !0;\n  }\n  return !1;\n}\nfunction d(_x, _x2, _x3) {\n  return _d.apply(this, arguments);\n}\nfunction _d() {\n  _d = _asyncToGenerator(function* (t, o, s) {\n    if (!t) throw new r(\"network-service:missing-url\", \"Url to Network service is missing\");\n    const n = a({\n        f: \"json\",\n        token: o\n      }, s),\n      {\n        data: l\n      } = yield e(t, n),\n      u = l.currentVersion >= 10.4 ? p(t, o, s) : v(t, s),\n      {\n        defaultTravelMode: f,\n        supportedTravelModes: c\n      } = yield u;\n    return l.defaultTravelMode = f, l.supportedTravelModes = c, i.fromJSON(l);\n  });\n  return _d.apply(this, arguments);\n}\nfunction v(_x4, _x5) {\n  return _v.apply(this, arguments);\n}\nfunction _v() {\n  _v = _asyncToGenerator(function* (r, t) {\n    const i = a({\n        f: \"json\"\n      }, t),\n      {\n        data: l\n      } = yield e(r.replace(/\\/rest\\/.*$/i, \"/info\"), i);\n    if (!l?.owningSystemUrl) return {\n      supportedTravelModes: [],\n      defaultTravelMode: null\n    };\n    const {\n        owningSystemUrl: u\n      } = l,\n      f = s(u) + \"/sharing/rest/portals/self\",\n      {\n        data: c\n      } = yield e(f, i),\n      d = o(\"helperServices.routingUtilities.url\", c);\n    if (!d) return {\n      supportedTravelModes: [],\n      defaultTravelMode: null\n    };\n    const v = n(u),\n      p = /\\/solve$/i.test(v.path) ? \"Route\" : /\\/solveclosestfacility$/i.test(v.path) ? \"ClosestFacility\" : \"ServiceAreas\",\n      m = a({\n        f: \"json\",\n        serviceName: p\n      }, t),\n      h = s(d) + \"/GetTravelModes/execute\",\n      g = yield e(h, m),\n      w = [];\n    let T = null;\n    if (g?.data?.results?.length) {\n      const e = g.data.results;\n      for (const r of e) if (\"supportedTravelModes\" === r.paramName) {\n        if (r.value?.features) for (const {\n          attributes: e\n        } of r.value.features) if (e) {\n          const r = JSON.parse(e.TravelMode);\n          w.push(r);\n        }\n      } else \"defaultTravelMode\" === r.paramName && (T = r.value);\n    }\n    return {\n      supportedTravelModes: w,\n      defaultTravelMode: T\n    };\n  });\n  return _v.apply(this, arguments);\n}\nfunction p(_x6, _x7, _x8) {\n  return _p.apply(this, arguments);\n}\nfunction _p() {\n  _p = _asyncToGenerator(function* (t, o, n) {\n    try {\n      const r = a({\n          f: \"json\",\n          token: o\n        }, n),\n        i = s(t) + \"/retrieveTravelModes\",\n        {\n          data: {\n            supportedTravelModes: l,\n            defaultTravelMode: u\n          }\n        } = yield e(i, r);\n      return {\n        supportedTravelModes: l,\n        defaultTravelMode: u\n      };\n    } catch (i) {\n      throw new r(\"network-service:retrieveTravelModes\", \"Could not get to the NAServer's retrieveTravelModes.\", {\n        error: i\n      });\n    }\n  });\n  return _p.apply(this, arguments);\n}\nexport { u as collectGeometries, f as dropZValuesOffInputGeometry, d as fetchServiceDescription, c as isInputGeometryZAware };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}