{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.28/esri/copyright.txt for details.\n*/\nimport { _ as t } from \"../chunks/tslib.es6.js\";\nimport { equals as e } from \"../core/arrayUtils.js\";\nimport { clone as r } from \"../core/lang.js\";\nimport { property as s } from \"../core/accessorSupport/decorators/property.js\";\nimport \"../core/accessorSupport/ensureType.js\";\nimport { subclass as n } from \"../core/accessorSupport/decorators/subclass.js\";\nimport { writer as i } from \"../core/accessorSupport/decorators/writer.js\";\nimport o from \"./Extent.js\";\nimport a from \"./Geometry.js\";\nimport l from \"./Point.js\";\nimport h from \"./SpatialReference.js\";\nimport { polygonCentroid as p } from \"./support/centroid.js\";\nimport { polygonContainsPoint as u } from \"./support/contains.js\";\nimport { isClockwise as c } from \"./support/coordsUtils.js\";\nimport { getPolygonExtent as f } from \"./support/extentUtils.js\";\nimport { isSelfIntersecting as m } from \"./support/intersectsBase.js\";\nimport { project as g } from \"./support/webMercatorUtils.js\";\nimport { updateSupportFromPoint as y } from \"./support/zmUtils.js\";\nvar d;\nfunction R(t) {\n  return !Array.isArray(t[0]);\n}\nlet x = d = class extends a {\n  static fromExtent(t) {\n    const e = t.clone().normalize(),\n      r = t.spatialReference;\n    let s = !1,\n      n = !1;\n    for (const o of e) o.hasZ && (s = !0), o.hasM && (n = !0);\n    const i = {\n      rings: e.map(t => {\n        const e = [[t.xmin, t.ymin], [t.xmin, t.ymax], [t.xmax, t.ymax], [t.xmax, t.ymin], [t.xmin, t.ymin]];\n        if (s && t.hasZ) {\n          const r = t.zmin + .5 * (t.zmax - t.zmin);\n          for (let t = 0; t < e.length; t++) e[t].push(r);\n        }\n        if (n && t.hasM) {\n          const r = t.mmin + .5 * (t.mmax - t.mmin);\n          for (let t = 0; t < e.length; t++) e[t].push(r);\n        }\n        return e;\n      }),\n      spatialReference: r\n    };\n    return s && (i.hasZ = !0), n && (i.hasM = !0), new d(i);\n  }\n  constructor(...t) {\n    super(...t), this.rings = [], this.type = \"polygon\";\n  }\n  normalizeCtorArgs(t, e) {\n    let r,\n      s,\n      n = null,\n      i = null;\n    return t && !Array.isArray(t) ? (n = t.rings ?? null, e || (t.spatialReference ? e = t.spatialReference : t.rings || (e = t)), r = t.hasZ, s = t.hasM) : n = t, n = n || [], e = e || h.WGS84, n.length && null != n[0]?.[0] && \"number\" == typeof n[0][0] && (n = [n]), i = n[0]?.[0], i && (void 0 === r && void 0 === s ? (r = i.length > 2, s = i.length > 3) : void 0 === r ? r = s ? i.length > 3 : i.length > 2 : void 0 === s && (s = r ? i.length > 3 : i.length > 2)), {\n      rings: n,\n      spatialReference: e,\n      hasZ: r,\n      hasM: s\n    };\n  }\n  get cache() {\n    return this.commitProperty(\"rings\"), this.commitProperty(\"hasZ\"), this.commitProperty(\"hasM\"), this.commitProperty(\"spatialReference\"), {};\n  }\n  get centroid() {\n    const t = p(this);\n    if (!t || isNaN(t[0]) || isNaN(t[1]) || this.hasZ && isNaN(t[2])) return null;\n    const e = new l();\n    return e.x = t[0], e.y = t[1], e.spatialReference = this.spatialReference, this.hasZ && (e.z = t[2]), e;\n  }\n  get extent() {\n    const {\n        spatialReference: t\n      } = this,\n      e = f(this);\n    if (!e) return null;\n    const r = new o(e);\n    return r.spatialReference = t, r;\n  }\n  get isSelfIntersecting() {\n    return m(this.rings);\n  }\n  writeRings(t, e) {\n    e.rings = r(this.rings);\n  }\n  addRing(t) {\n    if (!t) return;\n    const e = this.rings,\n      r = e.length;\n    if (R(t)) {\n      const s = [];\n      for (let e = 0, r = t.length; e < r; e++) s[e] = t[e].toArray();\n      e[r] = s;\n    } else e[r] = t.concat();\n    return this.notifyChange(\"rings\"), this;\n  }\n  clone() {\n    const t = new d();\n    return t.spatialReference = this.spatialReference, t.rings = r(this.rings), t.hasZ = this.hasZ, t.hasM = this.hasM, t;\n  }\n  equals(t) {\n    if (this === t) return !0;\n    if (null == t) return !1;\n    const r = this.spatialReference,\n      s = t.spatialReference;\n    if (null != r != (null != s)) return !1;\n    if (null != r && null != s && !r.equals(s)) return !1;\n    if (this.rings.length !== t.rings.length) return !1;\n    const n = ([t, e, r, s], [n, i, o, a]) => t === n && e === i && (null == r && null == o || r === o) && (null == s && null == a || s === a);\n    for (let i = 0; i < this.rings.length; i++) {\n      const r = this.rings[i],\n        s = t.rings[i];\n      if (!e(r, s, n)) return !1;\n    }\n    return !0;\n  }\n  contains(t) {\n    if (!t) return !1;\n    const e = g(t, this.spatialReference);\n    return u(this, null != e ? e : t);\n  }\n  isClockwise(t) {\n    let e;\n    return e = R(t) ? t.map(t => this.hasZ ? this.hasM ? [t.x, t.y, t.z, t.m] : [t.x, t.y, t.z] : [t.x, t.y]) : t, c(e);\n  }\n  getPoint(t, e) {\n    if (!this._validateInputs(t, e)) return null;\n    const r = this.rings[t][e],\n      s = this.hasZ,\n      n = this.hasM;\n    return s && !n ? new l(r[0], r[1], r[2], void 0, this.spatialReference) : n && !s ? new l(r[0], r[1], void 0, r[2], this.spatialReference) : s && n ? new l(r[0], r[1], r[2], r[3], this.spatialReference) : new l(r[0], r[1], this.spatialReference);\n  }\n  insertPoint(t, e, r) {\n    return this._validateInputs(t, e, !0) ? (y(this, r), Array.isArray(r) || (r = r.toArray()), this.rings[t].splice(e, 0, r), this.notifyChange(\"rings\"), this) : this;\n  }\n  removePoint(t, e) {\n    if (!this._validateInputs(t, e)) return null;\n    const r = new l(this.rings[t].splice(e, 1)[0], this.spatialReference);\n    return this.notifyChange(\"rings\"), r;\n  }\n  removeRing(t) {\n    if (!this._validateInputs(t, null)) return null;\n    const e = this.rings.splice(t, 1)[0],\n      r = this.spatialReference,\n      s = e.map(t => new l(t, r));\n    return this.notifyChange(\"rings\"), s;\n  }\n  setPoint(t, e, r) {\n    return this._validateInputs(t, e) ? (y(this, r), Array.isArray(r) || (r = r.toArray()), this.rings[t][e] = r, this.notifyChange(\"rings\"), this) : this;\n  }\n  _validateInputs(t, e, r = !1) {\n    if (null == t || t < 0 || t >= this.rings.length) return !1;\n    if (null != e) {\n      const s = this.rings[t];\n      if (r && (e < 0 || e > s.length)) return !1;\n      if (!r && (e < 0 || e >= s.length)) return !1;\n    }\n    return !0;\n  }\n  toJSON(t) {\n    return this.write({}, t);\n  }\n};\nt([s({\n  readOnly: !0\n})], x.prototype, \"cache\", null), t([s({\n  readOnly: !0\n})], x.prototype, \"centroid\", null), t([s({\n  readOnly: !0\n})], x.prototype, \"extent\", null), t([s({\n  readOnly: !0\n})], x.prototype, \"isSelfIntersecting\", null), t([s({\n  type: [[[Number]]],\n  json: {\n    write: {\n      isRequired: !0\n    }\n  }\n})], x.prototype, \"rings\", void 0), t([i(\"rings\")], x.prototype, \"writeRings\", null), x = d = t([n(\"esri.geometry.Polygon\")], x), x.prototype.toJSON.isDefaultToJSON = !0;\nconst j = x;\nexport { j as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}