{"ast":null,"code":"import _asyncToGenerator from \"/home/alex/FindYourSGR/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.28/esri/copyright.txt for details.\n*/\nimport { _ as e } from \"./chunks/tslib.es6.js\";\nimport { version as t } from \"./kernel.js\";\nimport r from \"./Map.js\";\nimport i from \"./Viewpoint.js\";\nimport { isSome as o } from \"./core/arrayUtils.js\";\nimport s from \"./core/Collection.js\";\nimport n from \"./core/Error.js\";\nimport a from \"./core/Loadable.js\";\nimport { loadAll as p } from \"./core/loadAll.js\";\nimport l from \"./core/Logger.js\";\nimport { destroyMaybe as u } from \"./core/maybe.js\";\nimport { MultiOriginJSONMixin as m } from \"./core/MultiOriginJSONSupport.js\";\nimport { EsriPromiseMixin as h } from \"./core/Promise.js\";\nimport { debounce as c } from \"./core/promiseUtils.js\";\nimport { whenOnce as d } from \"./core/reactiveUtils.js\";\nimport { addQueryParameter as g, isDataProtocol as f, dataComponents as w } from \"./core/urlUtils.js\";\nimport { property as y } from \"./core/accessorSupport/decorators/property.js\";\nimport \"./core/accessorSupport/ensureType.js\";\nimport \"./core/has.js\";\nimport { reader as b } from \"./core/accessorSupport/decorators/reader.js\";\nimport { subclass as A } from \"./core/accessorSupport/decorators/subclass.js\";\nimport { writer as S } from \"./core/accessorSupport/decorators/writer.js\";\nimport { readLoadable as v } from \"./core/accessorSupport/read.js\";\nimport _ from \"./geometry/SpatialReference.js\";\nimport j from \"./networks/UtilityNetwork.js\";\nimport V from \"./portal/PortalItem.js\";\nimport { TypeKeyword as I } from \"./portal/support/portalItemUtils.js\";\nimport U from \"./support/MapFloorInfo.js\";\nimport P from \"./webdoc/GeotriggersInfo.js\";\nimport { SaveOperationType as O } from \"./webdoc/interfaces.js\";\nimport k from \"./webdoc/RangeInfo.js\";\nimport { loadFromSource as L } from \"./webdoc/webdocLoadUtils.js\";\nimport F from \"./webdoc/Widgets.js\";\nimport { getOptimalThumbnailSize as N } from \"./webdoc/support/thumbnailUtils.js\";\nimport { getLayerJSON as R } from \"./webdoc/support/writeUtils.js\";\nimport T from \"./webmap/ApplicationProperties.js\";\nimport E from \"./webmap/Bookmark.js\";\nimport B from \"./webmap/InitialViewProperties.js\";\nimport { Version as J } from \"./webmap/Version.js\";\nimport x from \"./webmap/background/ColorBackground.js\";\nconst M = new J(2, 29),\n  Z = \"Web Map\",\n  W = \"webmap\",\n  $ = \"web-map\",\n  C = s.ofType(E),\n  G = s.ofType(j),\n  z = new Map([[\"image/jpeg\", \"jpeg\"], [\"image/jpg\", \"jpg\"], [\"image/png\", \"png\"], [\"image/gif\", \"gif\"]]),\n  D = \"ArcGIS Pro\",\n  q = I.JSAPI,\n  H = {\n    currentVersion: M,\n    createInitialViewProperties: () => new B(),\n    parseVersion: J.parse,\n    itemType: Z,\n    name: W,\n    origin: $\n  };\nlet K = class extends m(a.LoadableMixin(h(r))) {\n  constructor(e) {\n    var _this;\n    (super(e), _this = this), this._isAuthoringAppSetByUser = !1, this._isAuthoringAppVersionSetByUser = !1, this._thumbnailFilename = null, this._updateFromPromise = null, this.resourceReferences = {\n      portalItem: null,\n      paths: []\n    }, this.applicationProperties = null, this.bookmarks = new C(), this.floorInfo = null, this.geotriggersInfo = null, this.initialViewProperties = new B(), this.portalItem = null, this.presentation = null, this.sourceVersion = null, this.widgets = null, this.utilityNetworks = null, this._debouncedSaveOperations = c( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (e, t, r) {\n        const {\n          save: i,\n          saveAs: o\n        } = yield import(\"./webdoc/webdocSaveUtils.js\");\n        switch (e) {\n          case O.SAVE:\n            return i(H, _this, t);\n          case O.SAVE_AS:\n            return o(H, _this, r, t);\n        }\n      });\n      return function (_x, _x2, _x3) {\n        return _ref.apply(this, arguments);\n      };\n    }()), this.authoringApp = this.authoringAppVersion = null, this._isAuthoringAppSetByUser = this._isAuthoringAppVersionSetByUser = !1;\n  }\n  destroy() {\n    if (this.portalItem = u(this.portalItem), this.utilityNetworks) {\n      const e = this.utilityNetworks.removeAll();\n      for (const t of e) t.destroy();\n      this.utilityNetworks.destroy();\n    }\n  }\n  initialize() {\n    if (this.when().catch(e => {\n      l.getLogger(this).error(\"#load()\", \"Failed to load web map\", e);\n    }), this.resourceInfo) {\n      let t;\n      try {\n        t = this._validateJSON(this.resourceInfo);\n      } catch (e) {\n        return void this.addResolvingPromise(Promise.reject(e));\n      }\n      this.read(t);\n    }\n  }\n  set authoringApp(e) {\n    this._isAuthoringAppSetByUser = !0, this._set(\"authoringApp\", e);\n  }\n  writeAuthoringApp(e, t) {\n    e && this._isAuthoringAppSetByUser ? t.authoringApp = e : t.authoringApp = q;\n  }\n  set authoringAppVersion(e) {\n    this._isAuthoringAppVersionSetByUser = !0, this._set(\"authoringAppVersion\", e);\n  }\n  writeAuthoringAppVersion(e, r) {\n    e && this._isAuthoringAppVersionSetByUser ? r.authoringAppVersion = e : r.authoringAppVersion = t;\n  }\n  readInitialViewProperties(e, t) {\n    const r = new B();\n    t.background && (r.background = x.fromJSON(t.background));\n    const o = t.initialState?.viewpoint;\n    if (o) {\n      if (o.rotation) {\n        J.parse(t.version || \"\", \"webmap\").lessThan(2, 20) && t.authoringApp === D && (o.rotation *= -1);\n      }\n      r.viewpoint = i.fromJSON(o);\n    }\n    return t.mapRangeInfo && (r.rangeInfo = k.fromJSON(t.mapRangeInfo)), t.spatialReference && (r.spatialReference = _.fromJSON(t.spatialReference)), t.timeZone && (r.timeZone = t.timeZone), r;\n  }\n  writeInitialViewProperties(e, t, r, i) {\n    e && (e.background?.color && (t.background = e.background.write({}, i)), e.viewpoint && (t.initialState = {\n      viewpoint: e.viewpoint.write({}, i)\n    }), e.rangeInfo && (t.mapRangeInfo = e.rangeInfo.toJSON(i)), e.spatialReference && (t.spatialReference = e.spatialReference.write({}, i)), t.timeZone = e.timeZone);\n  }\n  writeLayers(e, t, r, i) {\n    t[r] = this._writeLayers(e, i, \"operational-layers\");\n  }\n  readSourceVersion(e, t) {\n    const [r, i] = t.version.split(\".\");\n    return new J(parseInt(r, 10), parseInt(i, 10));\n  }\n  writeSourceVersion(e, t, r) {\n    t[r] = `${M.major}.${M.minor}`;\n  }\n  writeTables(e, t, r, i) {\n    const o = this._writeLayers(e, i, \"tables\");\n    o.length && (t[r] = o);\n  }\n  get thumbnailUrl() {\n    return this.portalItem?.thumbnailUrl || null;\n  }\n  set thumbnailUrl(e) {\n    e ? (this._override(\"thumbnailUrl\", e), this._thumbnailFilename = this._generateCustomThumbnailFilename(e)) : this._clearThumbnailOverride();\n  }\n  get updatingFromView() {\n    return !!this._updateFromPromise;\n  }\n  load(e) {\n    return this.addResolvingPromise(L(H, this)), Promise.resolve(this);\n  }\n  loadAll() {\n    return p(this, e => {\n      e(this.ground, this.basemap, this.layers, this.tables);\n    });\n  }\n  read(e, t) {\n    t = {\n      ...t,\n      origin: $\n    };\n    const r = this._getAuthoringPropsState();\n    v(this, e, t => super.read(e, t), t), this._restoreAuthoringPropsFromState(r);\n  }\n  write(e, t) {\n    if (\"loaded\" !== this.loadStatus) {\n      const e = new n(\"webmap:not-loaded\", \"Web map must be loaded before it can be serialized\");\n      throw l.getLogger(this).error(\"#toJSON()\", \"Web map must be loaded before it can be serialized\", this.loadError || this.loadStatus), e;\n    }\n    return this._removeDanglingLayerRefs(), t = {\n      ...t,\n      origin: $,\n      restrictedWebMapWriting: !0,\n      webmap: this\n    }, super.write(e, t);\n  }\n  save(e) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2._debouncedSaveOperations(O.SAVE, e);\n    })();\n  }\n  saveAs(e, t) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return _this3._debouncedSaveOperations(O.SAVE_AS, t, e);\n    })();\n  }\n  updateFrom(e, t) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const r = _this4._updateFromInternal(e, t);\n      _this4._updateFromPromise = r, yield r;\n      r === _this4._updateFromPromise && (_this4._updateFromPromise = null);\n    })();\n  }\n  getLayerJSONFromResourceInfo(e) {\n    const t = this.resourceInfo;\n    return this._collectAllLayersJSON([...(t?.baseMap?.baseMapLayers || []), ...(t?.operationalLayers || []), ...(this.basemap?.resourceInfo?.data?.baseMapLayers || [])]).find(t => t.id === e.id);\n  }\n  updateItemThumbnail() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      _this5.thumbnailUrl && _this5._isOverridden(\"thumbnailUrl\") && (yield _this5.portalItem?.updateThumbnail({\n        thumbnail: _this5.thumbnailUrl,\n        filename: _this5._thumbnailFilename\n      }), _this5._clearThumbnailOverride());\n    })();\n  }\n  getThumbnailState() {\n    let e = this.thumbnailUrl;\n    return e && (e = this._isOverridden(\"thumbnailUrl\") ? e : g(e, \"w\", \"8192\")), {\n      thumbnailUrl: e,\n      filename: this._thumbnailFilename\n    };\n  }\n  restoreThumbnailFromState(e) {\n    this.thumbnailUrl = e.thumbnailUrl, this._thumbnailFilename = e.filename;\n  }\n  _collectAllLayersJSON(e) {\n    return e.reduce((e, t) => (e.push(t), \"GroupLayer\" === t.layerType && (e = e.concat(this._collectAllLayersJSON(t.layers || []))), e), []);\n  }\n  _writeLayers(e, t, r) {\n    t = {\n      ...t,\n      layerContainerType: r\n    };\n    return e.map(e => R(e, \"tables\" === r ? null : this.getLayerJSONFromResourceInfo(e), t)).filter(o).toArray();\n  }\n  _validateJSON(e) {\n    const t = J.parse(e.version || \"\", \"webmap\");\n    return M.validate(t), e.version = `${t.major}.${t.minor}`, e;\n  }\n  _removeDanglingLayerRefs() {\n    const e = this.applicationProperties,\n      t = e?.viewing?.search,\n      r = e => this.allLayers.some(t => t.id === e);\n    if (t && t.layers && (t.layers = t.layers.filter(e => r(e.id))), t && t.tables && (t.tables = t.tables.filter(e => this.tables.some(t => t.id === e.id))), e) {\n      const t = e.editing?.locationTracking;\n      t?.info && !r(t.info.layerId) && (e.editing = null);\n    }\n    const i = this.presentation?.slides;\n    i && i.forEach(e => {\n      e.visibleLayers && (e.visibleLayers = e.visibleLayers.filter(e => r(e.id)));\n    });\n  }\n  _updateFromInternal(e, t) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (t ??= {}, yield d(() => e.ready), _this6._updateInitialViewProperties(e, t), e.map === _this6) for (const r of e.allLayerViews) \"visible\" in r && \"visible\" in r.layer && r._isOverridden(\"visible\") && (r.layer.visible = r.visible), \"featureEffect\" in r && \"featureEffect\" in r.layer && r._isOverridden(\"featureEffect\") && (r.layer.featureEffect = r.featureEffect);\n      yield _this6._updateThumbnailUrl(e, t);\n    })();\n  }\n  _updateInitialViewProperties(e, t) {\n    if (t.backgroundExcluded || (this.initialViewProperties.background = e.background?.clone()), this.initialViewProperties.spatialReference = e.spatialReference?.clone(), this.initialViewProperties.timeZone = e.timeZone, t.viewpointExcluded || (this.initialViewProperties.viewpoint = new i({\n      rotation: e.rotation,\n      scale: t.scalePreserved ? e.scale : null,\n      targetGeometry: this._getViewExtent(e)\n    })), !t.widgetsExcluded) for (const r of e.persistableViewModels) r.updateWebDocument(this);\n  }\n  _getViewExtent(e) {\n    const t = e.center.clone().normalize(),\n      r = e.extent.clone(),\n      i = r.width / 2;\n    return r.xmin = t.x - i, r.xmax = t.x + i, r;\n  }\n  _updateThumbnailUrl(e, t) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (t.thumbnailExcluded) return;\n      const r = N(e, t.thumbnailSize),\n        i = yield e.takeScreenshot({\n          format: \"png\",\n          width: r.width,\n          height: r.height\n        });\n      _this7._setAutoGeneratedThumbnail(i.dataUrl);\n    })();\n  }\n  _setAutoGeneratedThumbnail(e) {\n    this.thumbnailUrl = e, this._thumbnailFilename = null;\n  }\n  _clearThumbnailOverride() {\n    this._clearOverride(\"thumbnailUrl\"), this.clear(\"thumbnailUrl\", \"user\"), this._thumbnailFilename = null;\n  }\n  _generateCustomThumbnailFilename(e) {\n    if (f(e)) {\n      const t = w(e),\n        r = t?.mediaType,\n        i = r && z.get(r.toLowerCase()) || null,\n        o = `thumbnail${Date.now()}`;\n      return i ? `${o}.${i}` : o;\n    }\n    return null;\n  }\n  _getAuthoringPropsState() {\n    return {\n      authoringApp: this.authoringApp,\n      authoringAppVersion: this.authoringAppVersion,\n      isAuthoringAppSetByUser: this._isAuthoringAppSetByUser,\n      isAuthoringAppVersionSetByUser: this._isAuthoringAppVersionSetByUser\n    };\n  }\n  _restoreAuthoringPropsFromState(e) {\n    e.isAuthoringAppSetByUser ? this.authoringApp = e.authoringApp : this._isAuthoringAppSetByUser = !1, e.isAuthoringAppVersionSetByUser ? this.authoringAppVersion = e.authoringAppVersion : this._isAuthoringAppVersionSetByUser = !1;\n  }\n  static fromJSON(e) {\n    const t = e;\n    if (!t) throw new n(\"webmap:empty-resource\", \"Expected a JSON resource but got nothing\");\n    return new this({\n      resourceInfo: t\n    });\n  }\n};\nK.VERSION = M, e([y()], K.prototype, \"_updateFromPromise\", void 0), e([y({\n  type: T,\n  json: {\n    write: !0\n  }\n})], K.prototype, \"applicationProperties\", void 0), e([y({\n  type: String,\n  json: {\n    write: {\n      allowNull: !0,\n      ignoreOrigin: !0\n    }\n  }\n})], K.prototype, \"authoringApp\", null), e([S(\"authoringApp\")], K.prototype, \"writeAuthoringApp\", null), e([y({\n  type: String,\n  json: {\n    write: {\n      allowNull: !0,\n      ignoreOrigin: !0\n    }\n  }\n})], K.prototype, \"authoringAppVersion\", null), e([S(\"authoringAppVersion\")], K.prototype, \"writeAuthoringAppVersion\", null), e([y({\n  type: C,\n  json: {\n    write: {\n      overridePolicy: e => ({\n        enabled: !!(e && e.length > 0),\n        ignoreOrigin: !0\n      })\n    }\n  }\n})], K.prototype, \"bookmarks\", void 0), e([y({\n  type: U,\n  json: {\n    name: \"mapFloorInfo\",\n    write: !0\n  }\n})], K.prototype, \"floorInfo\", void 0), e([y({\n  type: P,\n  json: {\n    write: !0\n  }\n})], K.prototype, \"geotriggersInfo\", void 0), e([y({\n  type: B,\n  nonNullable: !0,\n  json: {\n    read: {\n      source: [\"background\", \"initialState.viewpoint\", \"mapRangeInfo\", \"spatialReference\", \"timeZone\"]\n    },\n    write: {\n      ignoreOrigin: !0,\n      target: {\n        background: {\n          type: x\n        },\n        \"initialState.viewpoint\": {\n          type: i\n        },\n        mapRangeInfo: {\n          type: k\n        },\n        spatialReference: {\n          type: _\n        },\n        \"timeZone:\": {\n          type: String\n        }\n      }\n    }\n  }\n})], K.prototype, \"initialViewProperties\", void 0), e([b(\"initialViewProperties\")], K.prototype, \"readInitialViewProperties\", null), e([S(\"initialViewProperties\")], K.prototype, \"writeInitialViewProperties\", null), e([y({\n  json: {\n    read: !1,\n    write: {\n      target: \"operationalLayers\",\n      ignoreOrigin: !0\n    }\n  }\n})], K.prototype, \"layers\", void 0), e([S(\"layers\")], K.prototype, \"writeLayers\", null), e([y({\n  type: V\n})], K.prototype, \"portalItem\", void 0), e([y({\n  json: {\n    write: !0\n  }\n})], K.prototype, \"presentation\", void 0), e([y()], K.prototype, \"resourceInfo\", void 0), e([y({\n  readOnly: !0,\n  type: J,\n  json: {\n    read: {\n      source: \"version\"\n    },\n    write: {\n      allowNull: !0,\n      ignoreOrigin: !0,\n      target: \"version\",\n      isRequired: !0\n    }\n  }\n})], K.prototype, \"sourceVersion\", void 0), e([b(\"sourceVersion\")], K.prototype, \"readSourceVersion\", null), e([S(\"sourceVersion\")], K.prototype, \"writeSourceVersion\", null), e([y({\n  json: {\n    read: !1,\n    write: {\n      ignoreOrigin: !0\n    }\n  }\n})], K.prototype, \"tables\", void 0), e([S(\"tables\")], K.prototype, \"writeTables\", null), e([y()], K.prototype, \"thumbnailUrl\", null), e([y()], K.prototype, \"updatingFromView\", null), e([y({\n  type: F,\n  json: {\n    write: !0\n  }\n})], K.prototype, \"widgets\", void 0), e([y({\n  type: G,\n  json: {\n    read: !0,\n    write: !0\n  }\n})], K.prototype, \"utilityNetworks\", void 0), K = e([A(\"esri.WebMap\")], K);\nconst Q = K;\nexport { Q as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}