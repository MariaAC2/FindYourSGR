{"ast":null,"code":"import _asyncToGenerator from \"/home/alex/FindYourSGR/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.28/esri/copyright.txt for details.\n*/\nimport t from \"../../config.js\";\nimport e from \"../../core/Error.js\";\nimport n from \"../../core/Logger.js\";\nimport s from \"../Polygon.js\";\nimport o from \"../Polyline.js\";\nimport { getGeometryParts as r, cutParams as i, offsetMagnitude as l, updatePolyGeometry as c } from \"./normalizeUtilsCommon.js\";\nimport { getInfo as f } from \"./spatialReferenceUtils.js\";\nimport { geographicToWebMercator as u, webMercatorToGeographic as a } from \"./webMercatorUtils.js\";\nimport { cut as p } from \"../../rest/geometryService/cut.js\";\nimport { simplify as h } from \"../../rest/geometryService/simplify.js\";\nconst m = n.getLogger(\"esri.geometry.support.normalizeUtils\");\nfunction g(t) {\n  return \"polygon\" === t.type;\n}\nfunction y(t) {\n  return \"polygon\" === t[0].type;\n}\nfunction x(t) {\n  return \"polyline\" === t[0].type;\n}\nfunction d(t) {\n  const e = [];\n  let n = 0,\n    s = 0;\n  for (let o = 0; o < t.length; o++) {\n    const r = t[o];\n    let i = null;\n    for (let t = 0; t < r.length; t++) i = r[t], e.push(i), 0 === t ? (n = i[0], s = n) : (n = Math.min(n, i[0]), s = Math.max(s, i[0]));\n    i && e.push([(n + s) / 2, 0]);\n  }\n  return e;\n}\nfunction M(t, n) {\n  if (!(t instanceof o || t instanceof s)) {\n    const t = \"straightLineDensify: the input geometry is neither polyline nor polygon\";\n    throw m.error(t), new e(t);\n  }\n  const i = r(t),\n    l = [];\n  for (const e of i) {\n    const t = [];\n    l.push(t), t.push([e[0][0], e[0][1]]);\n    for (let s = 0; s < e.length - 1; s++) {\n      const o = e[s][0],\n        r = e[s][1],\n        i = e[s + 1][0],\n        l = e[s + 1][1],\n        c = Math.sqrt((i - o) * (i - o) + (l - r) * (l - r)),\n        f = (l - r) / c,\n        u = (i - o) / c,\n        a = c / n;\n      if (a > 1) {\n        for (let l = 1; l <= a - 1; l++) {\n          const e = l * n,\n            s = u * e + o,\n            i = f * e + r;\n          t.push([s, i]);\n        }\n        const e = (c + Math.floor(a - 1) * n) / 2,\n          s = u * e + o,\n          i = f * e + r;\n        t.push([s, i]);\n      }\n      t.push([i, l]);\n    }\n  }\n  return g(t) ? new s({\n    rings: l,\n    spatialReference: t.spatialReference\n  }) : new o({\n    paths: l,\n    spatialReference: t.spatialReference\n  });\n}\nfunction w(t, e, n) {\n  if (e) {\n    const e = M(t, 1e6);\n    t = a(e, !0);\n  }\n  return n && (t = c(t, n)), t;\n}\nfunction j(t, e, n) {\n  if (Array.isArray(t)) {\n    const s = t[0];\n    if (s > e) {\n      const n = l(s, e);\n      t[0] = s + n * (-2 * e);\n    } else if (s < n) {\n      const e = l(s, n);\n      t[0] = s + e * (-2 * n);\n    }\n  } else {\n    const s = t.x;\n    if (s > e) {\n      const n = l(s, e);\n      t = t.clone().offset(n * (-2 * e), 0);\n    } else if (s < n) {\n      const e = l(s, n);\n      t = t.clone().offset(e * (-2 * n), 0);\n    }\n  }\n  return t;\n}\nfunction b(t, e) {\n  let n = -1;\n  for (let s = 0; s < e.cutIndexes.length; s++) {\n    const o = e.cutIndexes[s],\n      i = e.geometries[s],\n      c = r(i);\n    for (let t = 0; t < c.length; t++) {\n      const e = c[t];\n      e.some(n => {\n        if (n[0] < 180) return !0;\n        {\n          let n = 0;\n          for (let t = 0; t < e.length; t++) {\n            const s = e[t][0];\n            n = s > n ? s : n;\n          }\n          n = Number(n.toFixed(9));\n          const s = -360 * l(n, 180);\n          for (let o = 0; o < e.length; o++) {\n            const e = i.getPoint(t, o);\n            i.setPoint(t, o, e.clone().offset(s, 0));\n          }\n          return !0;\n        }\n      });\n    }\n    if (o === n) {\n      if (y(t)) for (const e of r(i)) t[o] = t[o].addRing(e);else if (x(t)) for (const e of r(i)) t[o] = t[o].addPath(e);\n    } else n = o, t[o] = i;\n  }\n  return t;\n}\nfunction R(_x, _x2, _x3) {\n  return _R.apply(this, arguments);\n}\nfunction _R() {\n  _R = _asyncToGenerator(function* (e, n, r) {\n    if (!Array.isArray(e)) return R([e], n);\n    n && \"string\" != typeof n && m.warn(\"normalizeCentralMeridian()\", \"The url object is deprecated, use the url string instead\");\n    const a = \"string\" == typeof n ? n : n?.url ?? t.geometryServiceUrl;\n    let g,\n      y,\n      x,\n      d,\n      M,\n      v,\n      P,\n      L,\n      U = 0;\n    const z = [],\n      A = [];\n    for (const t of e) if (null != t) {\n      if (g || (g = t.spatialReference, y = f(g), x = g.isWebMercator, v = x ? 102100 : 4326, d = i[v].maxX, M = i[v].minX, P = i[v].plus180Line, L = i[v].minus180Line), y) {\n        if (\"mesh\" === t.type) A.push(t);else if (\"point\" === t.type) A.push(j(t.clone(), d, M));else if (\"multipoint\" === t.type) {\n          const e = t.clone();\n          e.points = e.points.map(t => j(t, d, M)), A.push(e);\n        } else if (\"extent\" === t.type) {\n          const e = t.clone()._normalize(!1, !1, y);\n          A.push(e.rings ? new s(e) : e);\n        } else if (t.extent) {\n          const e = t.extent,\n            n = l(e.xmin, M) * (2 * d);\n          let s = 0 === n ? t.clone() : c(t.clone(), n);\n          e.offset(n, 0), e.intersects(P) && e.xmax !== d ? (U = e.xmax > U ? e.xmax : U, s = w(s, x), z.push(s), A.push(\"cut\")) : e.intersects(L) && e.xmin !== M ? (U = e.xmax * (2 * d) > U ? e.xmax * (2 * d) : U, s = w(s, x, 360), z.push(s), A.push(\"cut\")) : A.push(s);\n        } else A.push(t.clone());\n      } else A.push(t);\n    } else A.push(t);\n    let S = l(U, d),\n      k = -90;\n    const C = S,\n      I = new o();\n    for (; S > 0;) {\n      const t = 360 * S - 180;\n      I.addPath([[t, k], [t, -1 * k]]), k *= -1, S--;\n    }\n    if (z.length > 0 && C > 0) {\n      const t = b(z, yield p(a, z, I, r)),\n        n = [],\n        s = [];\n      for (let r = 0; r < A.length; r++) {\n        const o = A[r];\n        if (\"cut\" !== o) s.push(o);else {\n          const o = t.shift(),\n            i = e[r];\n          null != i && \"polygon\" === i.type && i.rings && i.rings.length > 1 && o.rings.length >= i.rings.length ? (n.push(o), s.push(\"simplify\")) : s.push(x ? u(o) : o);\n        }\n      }\n      if (!n.length) return s;\n      const o = yield h(a, n, r),\n        i = [];\n      for (let e = 0; e < s.length; e++) {\n        const t = s[e];\n        \"simplify\" !== t ? i.push(t) : i.push(x ? u(o.shift()) : o.shift());\n      }\n      return i;\n    }\n    const X = [];\n    for (let t = 0; t < A.length; t++) {\n      const e = A[t];\n      if (\"cut\" !== e) X.push(e);else {\n        const t = z.shift();\n        X.push(!0 === x ? u(t) : t);\n      }\n    }\n    return X;\n  });\n  return _R.apply(this, arguments);\n}\nfunction v(t) {\n  if (!t) return null;\n  const e = t.extent;\n  if (!e) return null;\n  const n = t.spatialReference && f(t.spatialReference);\n  if (!n) return e;\n  const [s, o] = n.valid,\n    r = 2 * o,\n    {\n      width: i\n    } = e;\n  let l,\n    {\n      xmin: c,\n      xmax: u\n    } = e;\n  if ([c, u] = [u, c], \"extent\" === t.type || 0 === i || i <= o || i > r || c < s || u > o) return e;\n  switch (t.type) {\n    case \"polygon\":\n      if (!(t.rings.length > 1)) return e;\n      l = d(t.rings);\n      break;\n    case \"polyline\":\n      if (!(t.paths.length > 1)) return e;\n      l = d(t.paths);\n      break;\n    case \"multipoint\":\n      l = t.points;\n  }\n  const a = e.clone();\n  for (let f = 0; f < l.length; f++) {\n    let t = l[f][0];\n    t < 0 ? (t += o, u = Math.max(t, u)) : (t -= o, c = Math.min(t, c));\n  }\n  return a.xmin = c, a.xmax = u, a.width < i ? (a.xmin -= o, a.xmax -= o, a) : e;\n}\nfunction P(t, e, n) {\n  const s = f(n);\n  if (null == s) return t;\n  const [o, r] = s.valid,\n    i = 2 * r;\n  let l = 0,\n    c = 0;\n  e > r ? l = Math.ceil(Math.abs(e - r) / i) : e < o && (l = -Math.ceil(Math.abs(e - o) / i)), t > r ? c = Math.ceil(Math.abs(t - r) / i) : t < o && (c = -Math.ceil(Math.abs(t - o) / i));\n  let u = t + (l - c) * i;\n  const a = u - e;\n  return a > r ? u -= i : a < o && (u += i), u;\n}\nfunction L(t, e) {\n  const n = f(e);\n  if (n) {\n    const [e, s] = n.valid,\n      o = s - e;\n    if (t < e) for (; t < e;) t += o;\n    if (t > s) for (; t > s;) t -= o;\n  }\n  return t;\n}\nexport { P as getClosestDenormalizedXToReference, v as getDenormalizedExtent, R as normalizeCentralMeridian, L as normalizeMapX, M as straightLineDensify };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}