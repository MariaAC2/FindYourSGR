{"ast":null,"code":"import _asyncToGenerator from \"/home/alex/FindYourSGR/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.28/esri/copyright.txt for details.\n*/\nimport { _ as e } from \"../chunks/tslib.es6.js\";\nimport t from \"../Viewpoint.js\";\nimport i from \"../core/Collection.js\";\nimport r from \"../core/CollectionFlattener.js\";\nimport s from \"../core/Error.js\";\nimport has from \"../core/has.js\";\nimport a from \"../core/Logger.js\";\nimport { destroyMaybe as n } from \"../core/maybe.js\";\nimport { watch as o, sync as p, syncAndInitial as l } from \"../core/reactiveUtils.js\";\nimport { initialize as h } from \"../core/workers/workers.js\";\nimport { property as g } from \"../core/accessorSupport/decorators/property.js\";\nimport { cast as d } from \"../core/accessorSupport/decorators/cast.js\";\nimport \"../core/arrayUtils.js\";\nimport { subclass as u } from \"../core/accessorSupport/decorators/subclass.js\";\nimport { ensureClass as c } from \"../core/accessorSupport/ensureType.js\";\nimport { canProjectWithoutEngine as m, isLoadedOrLoad as y } from \"../geometry/projection.js\";\nimport w from \"../layers/support/TileInfo.js\";\nimport { BreakpointsOwner as f } from \"./BreakpointsOwner.js\";\nimport { DOMContainer as M } from \"./DOMContainer.js\";\nimport { PopupView as V } from \"./PopupView.js\";\nimport v from \"./View.js\";\nimport b from \"./2d/AnimationManager.js\";\nimport _ from \"./2d/FrameTask.js\";\nimport { GoToManager as S } from \"./2d/GoToManager.js\";\nimport { layerView2DImporter as j } from \"./2d/layerViewModuleImportUtils.js\";\nimport T from \"./2d/MapViewConstraints.js\";\nimport O from \"./2d/tiling/TileInfoView.js\";\nimport \"./2d/tiling/TileKey.js\";\nimport \"./2d/tiling/TileQueue.js\";\nimport \"./2d/tiling/TileStrategy.js\";\nimport { extentToScale as L } from \"./2d/viewpointUtils.js\";\nimport { ViewStateManager as k } from \"./2d/ViewStateManager.js\";\nimport R from \"./2d/input/MapViewInputManager.js\";\nimport C from \"./2d/layers/features/support/TileStore.js\";\nimport x from \"./2d/support/HighlightOptions.js\";\nimport { hitTest as D } from \"./2d/support/hitTestUtils.js\";\nimport { takeRawScreenshot as E, takeScreenshot as P } from \"./2d/support/screenshotUtils.js\";\nimport { StationaryManager as z } from \"./2d/support/StationaryManager.js\";\nimport { Timeline as G } from \"./2d/support/Timeline.js\";\nimport { isSupportedScreenPointEvent as U, createScreenPointFromSupportedEvent as q } from \"./support/screenUtils.js\";\nimport { check as I } from \"./support/WebGLRequirements.js\";\nimport A from \"./ui/DefaultUI.js\";\nimport F from \"./ui/2d/DefaultUI2D.js\";\nimport N from \"../webmap/background/ColorBackground.js\";\nlet W, $, H, B, Z, J;\nfunction K() {\n  return _K.apply(this, arguments);\n}\nfunction _K() {\n  _K = _asyncToGenerator(function* () {\n    const [, {\n      GraphicsView2D: e,\n      GraphicContainer: t,\n      LabelManager: i,\n      MapViewNavigation: r,\n      MagnifierView2D: s,\n      Stage: a\n    }] = yield Promise.all([import(\"./2d/webglDeps.js\"), import(\"./2d/mapViewDeps.js\")]);\n    $ = e, H = t, B = i, Z = r, J = s, W = a;\n  });\n  return _K.apply(this, arguments);\n}\nlet Q = class extends f(V(M(v))) {\n  constructor(e) {\n    var _this;\n    (super(e), _this = this), this._magnifierView = null, this.stage = null, this._resolveWhenReady = [], this.rootLayerViews = new r({\n      getCollections: () => [this.basemapView?.baseLayerViews, this.layerViews, this.basemapView?.referenceLayerViews],\n      getChildrenFunction: () => null\n    }), this.featuresTilingScheme = null, this.fullOpacity = 1, this.goToManager = new S({\n      view: this\n    }), this.graphicsView = null, this.stateManager = new k({\n      constraints: new T({\n        view: this\n      })\n    }), this.stationaryManager = new z(), this.labelManager = null, this.mapViewNavigation = null, this.renderingOptions = {\n      samplingMode: \"dynamic\",\n      edgeLabelsVisible: !0,\n      labelsAnimationTime: 125,\n      labelCollisionsEnabled: !0\n    }, this.supersampleScreenshotsEnabled = !0, this.supportsGround = !1, this.frameTask = new _(this), this.floors = new i(), this.highlightOptions = new x(), this.inputManager = new R({\n      view: this\n    }), this.map = null, this.spatialReferenceLocked = !1, this.timeline = new G(), this.type = \"2d\", this.ui = new F(), this.test = {\n      takeScreenshot: function () {\n        var _ref = _asyncToGenerator(function* (e) {\n          return E(_this._getScreenshotView(e), e);\n        });\n        return function takeScreenshot(_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()\n    }, this.padding = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }, this.addHandles([o(() => this.viewpoint, () => this.stationaryManager.flip(), p), this.on(\"resize\", e => this.stateManager.resize(e.width, e.height)), o(() => this.animationManager?.animation, e => {\n      this.animation = e;\n    })]), h();\n  }\n  destroy() {\n    this._set(\"preconditionsReady\", !1), this.frameTask = n(this.frameTask), this.goToManager.destroy(), this.rootLayerViews.destroy(), this.inputManager.destroy(), this._set(\"inputManager\", null);\n  }\n  get graphicsTileStore() {\n    return new C(this.featuresTilingScheme);\n  }\n  get constraintsInfo() {\n    const e = this.defaultsFromMap?.tileInfo,\n      t = this.spatialReference;\n    return {\n      lods: e?.spatialReference?.equals(t) ? e.lods : null,\n      spatialReference: t\n    };\n  }\n  get state() {\n    return this.stateManager.state;\n  }\n  get initialExtentRequired() {\n    if (!this.stateManager) return !1;\n    const {\n      scale: e,\n      constraints: t,\n      center: i,\n      viewpoint: r,\n      extent: s\n    } = this;\n    let a = this.zoom;\n    return !(this.map && \"initialViewProperties\" in this.map && this.map.initialViewProperties?.viewpoint) && !s && (t?.effectiveLODs || (a = -1), (!i || 0 === e && -1 === a) && (null == r?.targetGeometry || \"extent\" !== r.targetGeometry.type && !r.scale));\n  }\n  get _defaultsFromMapSettings() {\n    return {\n      required: {\n        tileInfo: !0,\n        heightModelInfo: !1,\n        extent: !1\n      },\n      requiresExtentInSpatialReference: this.spatialReferenceLocked\n    };\n  }\n  get typeSpecificPreconditionsReady() {\n    const e = this._getDefaultViewpoint();\n    if (!e) return !1;\n    const t = this.spatialReference,\n      i = e.targetGeometry;\n    return !!m(i.spatialReference, t) || y();\n  }\n  set animation(e) {\n    const t = this._get(\"animation\");\n    if (e === t) return;\n    if (t && t.stop(), !e || e.isFulfilled()) return this._set(\"animation\", null), void (this.frameTask.animationInProgress = !1);\n    this._set(\"animation\", e), this.frameTask.animationInProgress = !0;\n    const i = () => {\n      e === this._get(\"animation\") && (this._set(\"animation\", null), this.frameTask?.requestFrame()), this.frameTask.animationInProgress = !1;\n    };\n    e.when(i, i);\n  }\n  get background() {\n    return Y(this.map) ? this.map.initialViewProperties.background : null;\n  }\n  set background(e) {\n    this._override(\"background\", e);\n  }\n  get center() {\n    return this.stateManager?.center ?? null;\n  }\n  set center(e) {\n    this.stateManager.center = e;\n  }\n  get constraints() {\n    return this.stateManager?.constraints;\n  }\n  set constraints(e) {\n    e.view = this;\n    const t = this.stateManager.constraints;\n    this.stateManager.constraints = e, t?.destroy();\n  }\n  get extent() {\n    return this.stateManager?.extent ?? null;\n  }\n  set extent(e) {\n    this.stateManager.extent = e;\n  }\n  get padding() {\n    return this.stateManager?.padding;\n  }\n  set padding(e) {\n    this.stateManager && (this.stateManager.padding = e);\n  }\n  get rendering() {\n    return this.stage?.renderRequested ?? !1;\n  }\n  get resizeAlign() {\n    return this.stateManager.resizeAlign;\n  }\n  set resizeAlign(e) {\n    this.stateManager.resizeAlign = e;\n  }\n  get resolution() {\n    return this.stateManager.resolution ?? 0;\n  }\n  get rotation() {\n    return this.stateManager.rotation ?? 0;\n  }\n  set rotation(e) {\n    const {\n      rotationEnabled: t\n    } = this.constraints;\n    this.constraints.rotationEnabled = !0, this.stateManager.rotation = e, this.constraints.rotationEnabled = t;\n  }\n  get scale() {\n    return this.stateManager?.scale ?? 0;\n  }\n  set scale(e) {\n    this.stateManager && (this.stateManager.scale = e);\n  }\n  get stationary() {\n    return !this.animation && !this.navigating && !this.resizing && this.stationaryManager.stationary;\n  }\n  get updating() {\n    const e = !this.destroyed && (!this.layerViewManager || !this.labelManager || !this.graphicsView || !0 === this.layerViewManager.updating || !0 === this.labelManager.updating || !0 === this.graphicsView.updating || this.allLayerViews.some(e => !e.destroyed && !(\"layerViews\" in e) && !0 === e.updating));\n    if (has(\"esri-2d-log-updating\")) {\n      const t = this.allLayerViews.reduce((e, t) => ({\n        ...e,\n        [t.layer.id]: !t.destroyed && !(\"layerViews\" in t) && t.updating\n      }), {});\n      console.log(`Updating MapView: ${e}\\n-> Null LayerViewManager: ${!this.layerViewManager}\\n-> Null LabelManager: ${!this.labelManager}\\n-> Null GraphicsView: ${!this.graphicsView}\\n-> layerViewManager.updating: ${this.layerViewManager?.updating}\\n-> labelManager.updating: ${this.labelManager?.updating}\\n-> graphicsView.updating: ${this.graphicsView?.updating}\\n-> allLayerViews: ${JSON.stringify(t)}\\n`);\n    }\n    return e;\n  }\n  get viewpoint() {\n    return this.stateManager.viewpoint ?? null;\n  }\n  set viewpoint(e) {\n    this.stateManager.viewpoint = e, this.frameTask.requestFrame();\n  }\n  get zoom() {\n    return this.stateManager.zoom ?? -1;\n  }\n  set zoom(e) {\n    this.stateManager.zoom = e;\n  }\n  get navigating() {\n    return this.mapViewNavigation?.interacting ?? !1;\n  }\n  goTo(e, t) {\n    return this.goToManager.goTo(e, t);\n  }\n  hitTest(e, t) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return D(_this2, e, t);\n    })();\n  }\n  takeScreenshot(e) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return P(_this3._getScreenshotView(e), e);\n    })();\n  }\n  toMap(e) {\n    if (!this.ready) return null;\n    const t = U(e) ? q(this, e) : e;\n    return this.stateManager.toMap(t);\n  }\n  toScreen(e, t) {\n    return this.stateManager.toScreen(e, t);\n  }\n  on(e, t, i, r) {\n    const s = this.inputManager && this.viewEvents.on(e, t, i, r);\n    return s || super.on(e, t);\n  }\n  hasEventListener(e) {\n    return super.hasEventListener(e) || this.viewEvents.hasHandler(e);\n  }\n  whenLayerView(e) {\n    return super.whenLayerView(e);\n  }\n  graphicChanged(e) {\n    if (this.graphicsView) {\n      this.graphicsView.graphicUpdateHandler(e);\n    }\n  }\n  whenReady() {\n    return new Promise(e => {\n      this.ready ? e(this) : this._resolveWhenReady.push(e);\n    });\n  }\n  forceDOMReadyCycle() {\n    this.forceReadyCycle();\n  }\n  getDefaultSpatialReference() {\n    return this.map && \"initialViewProperties\" in this.map && this.map?.initialViewProperties?.spatialReference || this.defaultsFromMap?.spatialReference || null;\n  }\n  getDefaultTimeZone() {\n    return Y(this.map) ? this.map.initialViewProperties.timeZone : null;\n  }\n  hasLayerViewModule(e) {\n    return j.hasLayerViewModule(e);\n  }\n  importLayerView(e) {\n    return j.importLayerView(e);\n  }\n  pixelSizeAt() {\n    return this.ready ? this.resolution : (a.getLogger(this).error(\"#pixelSizeAt()\", \"Map view cannot be used before it is ready\"), null);\n  }\n  popupHitTest(e) {\n    return this.hitTest(e).then(t => ({\n      ...t,\n      mapPoint: this.toMap(e)\n    }));\n  }\n  requestUpdate() {\n    this.ready && this.frameTask.requestUpdate();\n  }\n  validate() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      let e = I(_this4.type);\n      if (has(\"safari\") && has(\"safari\") < 9 && (e = new s(\"mapview:browser-not-supported\", \"This browser is not supported by MapView (Safari < 9)\", {\n        type: \"safari\",\n        requiredVersion: 9,\n        detectedVersion: has(\"safari\")\n      })), null != e) throw a.getLogger(_this4).warn(\"#validate()\", e.message), e;\n    })();\n  }\n  loadAsyncDependencies() {\n    return K();\n  }\n  _getDefaultViewpoint() {\n    const {\n      constraints: e,\n      initialExtent: i,\n      map: r,\n      padding: s,\n      size: a\n    } = this;\n    if (!e) return null;\n    const n = r && \"initialViewProperties\" in r ? r.initialViewProperties : void 0,\n      o = this.stateManager.getUserStartupOptions(this.size),\n      p = n?.viewpoint,\n      l = p?.targetGeometry?.extent ?? i,\n      h = l?.center,\n      g = p?.rotation ?? 0,\n      d = p?.scale || l && L(l, [a[0] - s.left - s.right, a[1] - s.top - s.bottom]),\n      u = o.center ?? h,\n      c = o.rotation ?? g,\n      m = o.scale ?? d;\n    return u && m ? new t({\n      targetGeometry: u,\n      scale: m,\n      rotation: c\n    }) : null;\n  }\n  _startup() {\n    this.timeline.begin(\"MapView Startup\");\n    const e = this._getDefaultViewpoint();\n    this.stateManager.startup(e, this.size, this.spatialReference, this.defaultsFromMap.extent?.center), this.graphics.owner = this;\n    const t = new W(this.surface, {\n      canvas: this.renderCanvas,\n      contextOptions: {\n        disabledExtensions: this.deactivatedWebGLExtensions,\n        debugWebGLExtensions: this.debugWebGLExtensions\n      },\n      renderingOptions: this.renderingOptions,\n      timeline: this.timeline\n    });\n    this.stage = t, this._magnifierView = new J(), this._magnifierView.magnifier = this.magnifier;\n    const i = new B({\n      view: this\n    });\n    this._set(\"labelManager\", i);\n    const r = new b({\n      view: this\n    });\n    this._set(\"animationManager\", r);\n    const s = new Z({\n      view: this,\n      animationManager: r\n    });\n    this._set(\"mapViewNavigation\", s), this._setupSpatialReferenceDependentProperties(), this.addHandles([this.rootLayerViews.on(\"change\", () => this._updateStageChildren()), t.on(\"webgl-error\", e => this.fatalError = e.error), o(() => this.stationary, e => t.stationary = e, l), o(() => this.background, e => {\n      t.backgroundColor = e?.color, this._magnifierView.backgroundColor = e?.color;\n    }, l), o(() => this.magnifier, e => this._magnifierView.magnifier = e, l), o(() => this.renderingOptions, e => t.renderingOptions = e, l), o(() => this.highlightOptions, e => t.highlightOptions = e, l), o(() => this.state.id, () => t.state = this.state, l)], \"map-view\"), this._updateStageChildren();\n    const a = this._resolveWhenReady;\n    this._resolveWhenReady = [], a.forEach(e => e(this)), this.timeline.end(\"MapView Startup\"), this.frameTask.start(), this._set(\"ready\", !0);\n  }\n  _teardown() {\n    this._destroySpatialReferenceDependentProperties(), this.removeHandles(\"map-view\"), this.mapViewNavigation.destroy(), this._set(\"mapViewNavigation\", null), this.animationManager.destroy(), this._set(\"animationManager\", null), this.layerViewManager.clear(), this.labelManager.destroy(), this._magnifierView.destroy(), this.stage.destroy(), this.stage = null, this._set(\"graphicsView\", null), this._magnifierView = null, this._set(\"labelManager\", null), this._set(\"mapViewNavigation\", null), this.graphics.owner = null, this.frameTask.stop(), this.stationaryManager.clear(), this._set(\"ready\", !1), this.stateManager.teardown(), this.animation = null;\n  }\n  _updateStageChildren() {\n    this.stage.removeAllChildren(), this.rootLayerViews.forEach(e => {\n      this.stage.addChild(e.container);\n    });\n    const e = this.graphicsView;\n    this.stage.addChild(e.container), this.stage.addChild(this._magnifierView);\n  }\n  _setupSpatialReferenceDependentProperties() {\n    const e = new O(w.create({\n      spatialReference: this.spatialReference,\n      size: 512,\n      numLODs: 36\n    }));\n    this._set(\"featuresTilingScheme\", e);\n    const t = new $({\n      view: this,\n      graphics: this.graphics,\n      requestUpdateCallback: () => this.requestUpdate(),\n      container: new H(e)\n    });\n    this._set(\"graphicsView\", t);\n  }\n  _destroySpatialReferenceDependentProperties() {\n    const e = this.graphicsView;\n    this._set(\"graphicsView\", null), e.destroy(), this._set(\"featuresTilingScheme\", null);\n  }\n  _getScreenshotView(e) {\n    const {\n      allLayerViews: t,\n      padding: i,\n      size: r,\n      stage: s\n    } = this;\n    return {\n      allLayerViews: t,\n      backgroundColor: e?.ignoreBackground ? null : this.background?.color,\n      padding: i,\n      size: r,\n      stage: s\n    };\n  }\n  _spatialReferenceChanged(e) {\n    if (this.ready) {\n      this.frameTask.stop();\n      for (const e of this.allLayerViews) e.processDetach();\n      this._destroySpatialReferenceDependentProperties(), this.stateManager.changeSpatialReference(e), this.stage.state = this.state, this._setupSpatialReferenceDependentProperties();\n      for (const e of this.allLayerViews) e.processAttach();\n      this.frameTask.requestFrame(), this.frameTask.start(), this._updateStageChildren();\n    }\n  }\n};\nQ.type = \"2d\", e([g({\n  readOnly: !0\n})], Q.prototype, \"animationManager\", void 0), e([g({\n  constructOnly: !0\n})], Q.prototype, \"deactivatedWebGLExtensions\", void 0), e([g({\n  constructOnly: !0\n})], Q.prototype, \"debugWebGLExtensions\", void 0), e([g({\n  readOnly: !0\n})], Q.prototype, \"featuresTilingScheme\", void 0), e([g({\n  readOnly: !0\n})], Q.prototype, \"fullOpacity\", void 0), e([g()], Q.prototype, \"goToManager\", void 0), e([g({\n  readOnly: !0\n})], Q.prototype, \"graphicsTileStore\", null), e([g()], Q.prototype, \"graphicsView\", void 0), e([g()], Q.prototype, \"stateManager\", void 0), e([g()], Q.prototype, \"constraintsInfo\", null), e([g({\n  readOnly: !0\n})], Q.prototype, \"state\", null), e([g()], Q.prototype, \"initialExtentRequired\", null), e([g()], Q.prototype, \"labelManager\", void 0), e([g({\n  readOnly: !0\n})], Q.prototype, \"mapViewNavigation\", void 0), e([g({\n  constructOnly: !0\n})], Q.prototype, \"renderCanvas\", void 0), e([g()], Q.prototype, \"renderingOptions\", void 0), e([g({\n  constructOnly: !0\n})], Q.prototype, \"supersampleScreenshotsEnabled\", void 0), e([g({\n  readOnly: !0\n})], Q.prototype, \"supportsGround\", void 0), e([g()], Q.prototype, \"_defaultsFromMapSettings\", null), e([g({\n  readOnly: !0\n})], Q.prototype, \"typeSpecificPreconditionsReady\", null), e([g()], Q.prototype, \"animation\", null), e([g({\n  type: N\n})], Q.prototype, \"background\", null), e([g()], Q.prototype, \"center\", null), e([g({\n  type: T\n})], Q.prototype, \"constraints\", null), e([g()], Q.prototype, \"extent\", null), e([g()], Q.prototype, \"floors\", void 0), e([g({\n  type: x\n})], Q.prototype, \"highlightOptions\", void 0), e([g({\n  readOnly: !0\n})], Q.prototype, \"inputManager\", void 0), e([g()], Q.prototype, \"map\", void 0), e([g()], Q.prototype, \"padding\", null), e([g({\n  readOnly: !0\n})], Q.prototype, \"rendering\", null), e([g()], Q.prototype, \"resizeAlign\", null), e([g({\n  readOnly: !0\n})], Q.prototype, \"resolution\", null), e([g()], Q.prototype, \"rotation\", null), e([g()], Q.prototype, \"scale\", null), e([g({\n  constructOnly: !0\n})], Q.prototype, \"spatialReferenceLocked\", void 0), e([g()], Q.prototype, \"stationary\", null), e([g({\n  type: G,\n  readOnly: !0\n})], Q.prototype, \"timeline\", void 0), e([g({\n  readOnly: !0\n})], Q.prototype, \"type\", void 0), e([g({\n  readOnly: !0\n})], Q.prototype, \"updating\", null), e([g()], Q.prototype, \"viewpoint\", null), e([g()], Q.prototype, \"zoom\", null), e([g({\n  readOnly: !0\n})], Q.prototype, \"navigating\", null), e([g(), d(e => e instanceof A ? e : c(F, e))], Q.prototype, \"ui\", void 0), Q = e([u(\"esri.views.MapView\")], Q);\nconst X = Q;\nfunction Y(e) {\n  return \"esri.WebMap\" === e?.declaredClass;\n}\nexport { X as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}