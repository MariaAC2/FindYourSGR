{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.28/esri/copyright.txt for details.\n*/\nimport { _ as t } from \"../../chunks/tslib.es6.js\";\nimport \"../../geometry.js\";\nimport { ClonableMixin as e } from \"../../core/Clonable.js\";\nimport r from \"../../core/Collection.js\";\nimport { JSONSupport as o } from \"../../core/JSONSupport.js\";\nimport { property as i } from \"../../core/accessorSupport/decorators/property.js\";\nimport { ensureClass as s } from \"../../core/accessorSupport/ensureType.js\";\nimport \"../../core/arrayUtils.js\";\nimport \"../../core/has.js\";\nimport { enumeration as n } from \"../../core/accessorSupport/decorators/enumeration.js\";\nimport { reader as p } from \"../../core/accessorSupport/decorators/reader.js\";\nimport { subclass as u } from \"../../core/accessorSupport/decorators/subclass.js\";\nimport { writer as l } from \"../../core/accessorSupport/decorators/writer.js\";\nimport { apiKey as a } from \"./commonProperties.js\";\nimport y from \"./DataLayer.js\";\nimport m from \"./FeatureSet.js\";\nimport { impedanceAttributeNameJsonMap as c, restrictionAttributeNameJsonMap as d, directionsLengthUnitJsonMap as v, directionsOutputTypeJsonMap as w, directionsStyleNameJsonMap as j, durationImpedanceAttributeNameJsonMap as h, lengthUnitJsonMap as S, outputLineJsonMap as B, restrictUTurnJsonMap as f } from \"./networkEnums.js\";\nimport b from \"./NetworkFeatureSet.js\";\nimport T from \"./NetworkUrl.js\";\nimport g from \"./TravelMode.js\";\nimport A from \"../../geometry/SpatialReference.js\";\nvar N;\nlet P = N = class extends e(o) {\n  constructor(t) {\n    super(t), this.accumulateAttributes = null, this.apiKey = null, this.attributeParameterValues = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsOutputType = null, this.directionsStyleName = null, this.directionsTimeAttribute = null, this.findBestSequence = null, this.geometryPrecision = null, this.geometryPrecisionM = null, this.geometryPrecisionZ = null, this.ignoreInvalidLocations = null, this.impedanceAttribute = null, this.outputGeometryPrecision = null, this.outputGeometryPrecisionUnits = null, this.outputLines = \"true-shape\", this.outSpatialReference = null, this.overrides = null, this.pointBarriers = null, this.polygonBarriers = null, this.polylineBarriers = null, this.preserveFirstStop = null, this.preserveLastStop = null, this.preserveObjectID = null, this.restrictionAttributes = null, this.restrictUTurns = null, this.returnBarriers = !1, this.returnDirections = !1, this.returnPolygonBarriers = !1, this.returnPolylineBarriers = !1, this.returnRoutes = !0, this.returnStops = !1, this.returnTraversedEdges = null, this.returnTraversedJunctions = null, this.returnTraversedTurns = null, this.returnZ = !0, this.startTime = null, this.startTimeIsUTC = !0, this.stops = null, this.timeWindowsAreUTC = null, this.travelMode = null, this.useHierarchy = null, this.useTimeWindows = null;\n  }\n  static from(t) {\n    return s(N, t);\n  }\n  readAccumulateAttributes(t) {\n    return null == t ? null : t.map(t => c.fromJSON(t));\n  }\n  writeAccumulateAttributes(t, e, r) {\n    t?.length && (e[r] = t.map(t => c.toJSON(t)));\n  }\n  writePointBarriers(t, e, r) {\n    D(t, e, r);\n  }\n  writePolygonBarrier(t, e, r) {\n    D(t, e, r);\n  }\n  writePolylineBarrier(t, e, r) {\n    D(t, e, r);\n  }\n  readRestrictionAttributes(t) {\n    return null == t ? null : t.map(t => d.fromJSON(t));\n  }\n  writeRestrictionAttributes(t, e, r) {\n    t?.length && (e[r] = t.map(t => d.toJSON(t)));\n  }\n  readStartTime(t, e) {\n    const {\n      startTime: r\n    } = e;\n    return null == r ? null : \"now\" === r ? \"now\" : new Date(r);\n  }\n  writeStartTime(t, e) {\n    null != t && (e.startTime = \"now\" === t ? \"now\" : t.getTime());\n  }\n  readStops(t, e) {\n    return C(e.stops);\n  }\n  writeStops(t, e, r) {\n    D(t, e, r);\n  }\n};\nt([i({\n  type: [String],\n  json: {\n    name: \"accumulateAttributeNames\",\n    write: !0\n  }\n})], P.prototype, \"accumulateAttributes\", void 0), t([p(\"accumulateAttributes\")], P.prototype, \"readAccumulateAttributes\", null), t([l(\"accumulateAttributes\")], P.prototype, \"writeAccumulateAttributes\", null), t([i(a)], P.prototype, \"apiKey\", void 0), t([i({\n  json: {\n    write: !0\n  }\n})], P.prototype, \"attributeParameterValues\", void 0), t([i({\n  type: String,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"directionsLanguage\", void 0), t([n(v)], P.prototype, \"directionsLengthUnits\", void 0), t([n(w)], P.prototype, \"directionsOutputType\", void 0), t([n(j)], P.prototype, \"directionsStyleName\", void 0), t([n(h, {\n  name: \"directionsTimeAttributeName\",\n  ignoreUnknown: !1\n})], P.prototype, \"directionsTimeAttribute\", void 0), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"findBestSequence\", void 0), t([i({\n  type: Number,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"geometryPrecision\", void 0), t([i({\n  type: Number,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"geometryPrecisionM\", void 0), t([i({\n  type: Number,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"geometryPrecisionZ\", void 0), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"ignoreInvalidLocations\", void 0), t([n(c, {\n  name: \"impedanceAttributeName\",\n  ignoreUnknown: !1\n})], P.prototype, \"impedanceAttribute\", void 0), t([i({\n  type: Number,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"outputGeometryPrecision\", void 0), t([n(S)], P.prototype, \"outputGeometryPrecisionUnits\", void 0), t([n(B)], P.prototype, \"outputLines\", void 0), t([i({\n  type: A,\n  json: {\n    name: \"outSR\",\n    write: !0\n  }\n})], P.prototype, \"outSpatialReference\", void 0), t([i({\n  json: {\n    write: !0\n  }\n})], P.prototype, \"overrides\", void 0), t([i({\n  json: {\n    name: \"barriers\",\n    write: !0\n  }\n})], P.prototype, \"pointBarriers\", void 0), t([l(\"pointBarriers\")], P.prototype, \"writePointBarriers\", null), t([i({\n  json: {\n    write: !0\n  }\n})], P.prototype, \"polygonBarriers\", void 0), t([l(\"polygonBarriers\")], P.prototype, \"writePolygonBarrier\", null), t([i({\n  json: {\n    write: !0\n  }\n})], P.prototype, \"polylineBarriers\", void 0), t([l(\"polylineBarriers\")], P.prototype, \"writePolylineBarrier\", null), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"preserveFirstStop\", void 0), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"preserveLastStop\", void 0), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"preserveObjectID\", void 0), t([i({\n  type: [String],\n  json: {\n    name: \"restrictionAttributeNames\",\n    write: !0\n  }\n})], P.prototype, \"restrictionAttributes\", void 0), t([p(\"restrictionAttributes\")], P.prototype, \"readRestrictionAttributes\", null), t([l(\"restrictionAttributes\")], P.prototype, \"writeRestrictionAttributes\", null), t([n(f)], P.prototype, \"restrictUTurns\", void 0), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"returnBarriers\", void 0), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"returnDirections\", void 0), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"returnPolygonBarriers\", void 0), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"returnPolylineBarriers\", void 0), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"returnRoutes\", void 0), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"returnStops\", void 0), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"returnTraversedEdges\", void 0), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"returnTraversedJunctions\", void 0), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"returnTraversedTurns\", void 0), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"returnZ\", void 0), t([i({\n  type: Date,\n  json: {\n    type: Number,\n    write: !0\n  }\n})], P.prototype, \"startTime\", void 0), t([p(\"startTime\")], P.prototype, \"readStartTime\", null), t([l(\"startTime\")], P.prototype, \"writeStartTime\", null), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"startTimeIsUTC\", void 0), t([i({\n  json: {\n    write: !0\n  }\n})], P.prototype, \"stops\", void 0), t([p(\"stops\")], P.prototype, \"readStops\", null), t([l(\"stops\")], P.prototype, \"writeStops\", null), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"timeWindowsAreUTC\", void 0), t([i({\n  type: g,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"travelMode\", void 0), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"useHierarchy\", void 0), t([i({\n  type: Boolean,\n  json: {\n    write: !0\n  }\n})], P.prototype, \"useTimeWindows\", void 0), P = N = t([u(\"esri.rest.support.RouteParameters\")], P);\nconst O = P;\nfunction U(t) {\n  return t && \"type\" in t;\n}\nfunction J(t) {\n  return t && \"features\" in t && \"doNotLocateOnRestrictedElements\" in t;\n}\nfunction L(t) {\n  return t && \"url\" in t;\n}\nfunction R(t) {\n  return t && \"features\" in t;\n}\nfunction C(t) {\n  return U(t) ? y.fromJSON(t) : L(t) ? T.fromJSON(t) : J(t) ? b.fromJSON(t) : R(t) ? m.fromJSON(t) : null;\n}\nfunction D(t, e, o) {\n  null != t && (e[o] = r.isCollection(t) ? {\n    features: t.toArray().map(t => t.toJSON())\n  } : t.toJSON());\n}\nexport { O as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}